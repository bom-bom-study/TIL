## Chapter6. AOP
### 6.1 트랜잭션 코드의 분리
트랜잭션의 경계는 비즈니스 로직 전후에 설정돼야 한다.
---
#### 6.1.1 메소드 분리
upgradeLevels() 에는 트랜잭션 경계설정과 비즈니스 로직이 공존한다.  
하지만 트랜잭션 경계설정 코드와 비즈니스로직 코드가 구분되어 있고 두 코드 간에 서로 주고 받는 코드가 없으므로 독립적인 코드라고 할 수 있다.  
따라서 두 개의 메소드로 분리할 수 있다. 

#### 6.1.2 DI를 이용한 클래스의 분리
UserService에 트랜잭션을 담당하는 기술적인 코드가 아직 남아있다. 이 문제를 해결하기 위해서는 트랜잭션 코드를 클래스 밖으로 뽑아내면 된다.

**DI 적용을 이용한 트랜잭션 분리**  
다른 클래스나 모듈에서 UserService를 호출해서 사용한다면 UserService 클래스를 직접 참조하게 된다. 트랜잭션 코드를 UserService 밖으로 빼버리면 UserService 클래스를 직접 사용하는 클라이언트 코드에서는 트랜잭션 기능이 빠진 UserService를 사용하게 된다. _(구현 클래스를 직접 참조하는 경우의 단점)_  

DI의 기본 아이디어
> 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하는 것
> 따라서 구현 클래스는 외부에서 변경 가능.

UserService를 인터페이스로 만들고 기존 코드는 UserService 인터페이스의 구현 클래스를 만들면 클라이언트와 결합이 약해지고 직접 구현 클래스에 의존하지 않기 때문에 확장이 가능해진다.  

한 번에 두 개의 UserService 인터페이스 구현 클래스를 동시에 이용하는 것도 가능하다. 트랜잭션의 경계설정은 UserServiceTx에서, UserServiceImpl에는 실제적인 로직 처리를 위임한다. 그 위임을 위한 호출 작업 이전과 이후에 트랜잭션 경계를 설정해주면 된다.  

**UserService 인터페이스 도입**  
UserServiceImpl은 기존 UserService 클래스의 내용을 대부분 그대로 유지하되, 트랜잭션과 관련된 코드는 제거한다.  

**분리된 트랜잭션 기능**  
UserServiceTx는 UserService를 구현하게 만든다. 그리고 같은 인터페이스를 구현한 다른 오브젝트에게 작업을 위임하게 만들면 되다.  
그 후 UserService에 transactionManager라는 이름의 빈으로 등록된 트랜잭션 매니저를 DI로 받아뒀다가 트랜잭션 안에서 동작하도록 만들어줘야 하는 메소드 호출의 전 후에 트랜잭션 경계설정 API를 사용하면 된다.  
```java
public class UserServiceTx implements UserService{
    // UserService를 구현한 다른 오브젝트를 DI 받는다.
    UserService userService;
    PlatformTransactionManager transactionManager;

    public void setTransactionManager(PlaformTransactionManager transactionManager){
        this.trasactionManager = transactionManager;
    }

    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    // DI 받은 UserService 오브젝트에 모든 기능 위임 
    public void add(User user){
        userService.add(user);
    }

    public void upgradeLevels() {
        TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
        try{
            userService.upgradeLevels();
            this.transactionManager.commit(status);
        } catch(RuntimeException e) {
            this.transactionManager.rollback(status);
            throw e;
        }
    }
}
```

**트랜잭션 적용을 위한 DI 설정**  
기존에 userService 빈이 의존하고 있던 transanctionManager는 UserServiceTx의 빈이, userDao와 mailSender는 UserServiceImpl 빈이 각각 의존하도록 프로퍼티 정보를 분리한다.  

클라이언트는 UserServiceTx 빈을 호출해서 사용하도록 만들어야 하고, userService 빈은 UserServiceImpl 클래스로 정의되는 userServiceImpl인 빈을 DI 하게 만든다.  

**트랜잭션 분리에 따른 테스트 수정**
기존에는 UserService 클래스 타입의 빈을 @Autowired로 가져다 사용했다.  
인터페이스도 @Autowired로 가져오는 데는 문제가 없지만, @Autowired는 타입이 일치하는 빈을 찾아주기 때문에 UserService라는 인터페이스 타입을 가진 두개의 빈이 존재하기 때문에 문제가 발생한다.  
타입으로 하나의 빈을 결정할 수 없는 경우에는 필드 이름을 이용해 빈을 찾는다.
```
@Autowired
UserService userService;
```

UserServiceTest는  UserServiceImpl 클래스로 정의된 빈도 필요하다.  
MailSender Mock 오브젝트를 이용한 테스트에서는 테스트에서 직접 MailSender를 DI 해줘야 하는데 MailSender를 DI 해줄 대상을 구체적으로 알고 있어야 하기 때문이다.  
```java
@Test
public void upgradeLevels() throws Exception {
    MockMailSender mockMailSender = new MockMailSender();
    userServicelmpl.setMailSender(mockMailSender);
} 
```

**트랜잭션 경계설정 코드 분리의 장점**  
1. 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션 같은 기술적인 내용은 신경쓰지 않아도 된다.  
트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 하면 된다. 
2. 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있다.

<br>

### 6.2 고립된 단위 테스트
---
#### 6.2.1 복잡한 의존관계 속의 테스트
UserService의 구현 클래스들이 동작하려면 세 가지 타입의 의존 오브젝트가 필요하다. (UserDao, MailSender, PlatfromTransactionManager)  
따라서 세가지 의존관계를 갖는 오브젝트들이 테스트가 진행되는 동안 같이 실행되기 때문에 의존관계를 따라 등장하는 오브젝트와 서비스, 환경 등이 모두 합쳐져 테스트 대상이 된다.  
#### 6.2.2 테스트 대상 오브젝트 고립시키기
**테스트를 위한 UserServiceImpl 고립**  
트랜잭션 코드를 독립시켰기 때문에 사용자 관리 로직을 담을 UserServiceImpl은 PlatformTransactionManager에 더 이상 의존하지 않는다.  

UserDao는 테스트 대상의 코드가 정상적으로 수행되도록 도와주는 스텁인 동시에 부가적인 검증 기능까지 가진 목 오브젝트이다. upgradeLevels()의 테스트 결과를 검증할 방법이 필요하기 때문이다.  
upgradeLevels()는 void 형이기 때문에 검증이 불가능하고 DB를 직접 확인할 수밖에 없다.  

그런데 UserServiceImpl은 아무리 그 기능이 수행되도 결과가 DB에도 남지 않는다. 이럴 땐 테스트 대상인  UserServiceImpl과 UserDao에 어떤 요청을 했는지 확인하는 작업이 필요하다.  

**고립된 단위 테스트 활용**  
테스트 작업을 분류해보면 UserService의 upgradeLevles() 메소드가 실행되는 동안에 사용하는 오브젝트가 테스트의 목적에 맞게 동작하도록 준비한다. (DB, MailSender 목 오브젝트 DI)  
실제 테스트 대상인 userService의 메소를 실행한 다음은 테스트 대상 코드를 실행한 후에 결과를 확인하는 작업이다. (DB 확인, 목 오브젝트를 통해 메소드 실행 중 메일 발송 요청이 나간 적이 있는지만 확인)  

**UserDao 목 오브젝트**  
DB 작업도 목 오브젝트로 만들 수 있다. 목 오브젝트는 기본적으로 스텁과 같은 방식으로 테스트 대상을 통해 사용될 때 필요한 기능을 지원해줘야 한다.   
upgradeLevels()가 실행되는 중에 UserDao와 어떤 정보를 주고받는지 알아야 한다.  
1. userDao.getAll() 
: 레벨 업그레이드 후보가 될 사용자의 목록을 받아온다. 
=> DB에서 읽어온 것처럼 미리 준비된 사용자 목록 제공

2. userDao.update(user)
: 리턴값이 없으므로 빈 메소드로 만들어도 된다.
하지만 레벨을 변경하는 부분을 검증할 수 있는 기능이므로 중요한 기능이다. 
업그레이드를 통해 레벨이 변경된 사용자는 DB에 반영되도록 userDao의 update()에 전달돼야 한다.  
따라서 getAll()에 대해서는 스텁으로, update()에 대해서는 목 오브젝트로서 동작하는 UserDao 타입의 테스트 대역이 필요하다. (MockUserDao)  

MockUserDao에는 두개의 User 타입 리스트를 정의해둔다. (생성자를 통해 전달받은 사용자 목록을 저장해뒀다가 getAll() 메소드가 호출되면 돌려주는 용도 / update() 메소드를 실행하면서 넘겨준 업그레이드 대상 User 오브젝트를 저장해뒀다가 검증을 위해 돌려주기 위한 용도)  

_MockUserDao를 사용해서 만든 고립된 테스트_
먼저 테스트하고 싶은 로직을 담은 클래스인 UserServiceImpl의 오브젝트를 직접 생성하고 MockUserDao 오브젝트를 사용하도록 수동 DI 해주면 된다.  
UserServiceImpl은 UserDao의 update()를 이용해 몇 명의 사용자 정보를 DB에 수정하려고 했는지, 사용자드링 누구인지, 어떤 레벨로 변경됐는지 확인하면 된다.  
먼저 레벨 업그레이드가 두 명에게만 일어났는지 update() 메소드를 호출해서 변경을 시도한 것만 확인하면 된다.  
MockUserDao에는 update() 가 호출될때마다 저장해 둔 사용자 목록이 있고, 목록의 수가 2이면 된다. 순서에 따라 업그레이드 된 사용자 아이디와 바뀐 레벨을 확인하면 된다.  

**테스트 수행 성능의 향상**  
UserServiceImpl과 테스트를 도와주는 두 개의 목 오브젝트 외에는 사용자 관리 로직을 검증하는 데 직접적으로 필요하지 않은 의존 오브젝트와 서비스를 모두 제거했기 때문에 빠른 테스트가 가능하다.  

#### 6.2.3 단위 테스트와 통합 테스트  
단위 테스트라는 용어를 사용할 때는 그 의미를 명확히 할 필요가 있다.  
(`단위 테스트`: 테스트 대상 글래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜 테스트 하는 것으로 정의)  
<-> (`통합 테스트`: 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트)


#### 6.2.4 목 프레임워크
**Mockito 프레임워크**  
목 오브젝트를 편리하게 작성하도록 도와주는 목 오브젝트 지원 프레임워크 중 하나.  
목 프레임워크는 목 클래스를 일일이 준비할 필요 없이 간단한 메소드 호출만드로 다이내믹하게 특정 인터페이스를 구현한 테스트 용 목 오브젝트를 만들 수 있다.  
``` java
UserDao mockuserDao = mock(UserDao.class);
```

getAll() 메소드가 불려올 때 사용자 목록을 리턴하도록 스텁 기능을 추가해야 한다.  
```java
when(mockUserDao.getAll().thenReturn(this.users));
```
mockUserDao.getAll()이 호출됐을 때, users 리스트를 리턴해주라는 선언   

update() 호출이 있는지 검증
```java
verify(mockUserDao, times(2)).update(andy(User.class));
```

* 목 오브젝트 사용하는 방법
    - 인터페이스를 이용해 목 오브젝트를 만든다.
    - 목 오브젝트가 리턴할 값이 있으면 지정해준다. 메소드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
    - 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
    - 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출 됐는지 검증

```java
@Test
public void mockUpgradeLevels() throws Exception {
    UserServicelmpl userServicelmpl =new UserServicelmpl();
    // UserDao의 목 오브젝트를 생성하고 getAll()이 호출됐을 때의 리턴 값을 설정해준 뒤 테스트 대상에 DI
    UserDao mockUserDao = mock(UserDao.class);
    when(mockUserDao.getAll()).thenReturn(this.users); 
    userServicelmpl.setUserDao(mockUserDao);

    MailSender mockMailSender = mock(MailSender.class);
    userServiceImpl.setMailSender(mockMailSender);

    userServiceImpl.upgradeLevels();

    // 목 오브젝트가 제공하는 검증 기능을 통해 어떤 메소드가 몇 번 호출 됐는지, 파라미터가 무엇인지 확인
    // times()는 메소드 호출 횟수 검증, any()는 파라미터 내용 무시
    verify(mockUserDao, times(2)).update(any(User.class));
    verify(mockUserDao, times(2)).update(any(User.class));
    verify(mockUserDao).update(users.get(1));
    assertThat(users.get(1).getLevel(), is(Level.SILVER));
    verify(mockUserDao).update(users.get(3));
    assertThat(users.get(3).getLevel(), is(Level.GOLD));

    ArgumentCaptor<SimpleMailMessage> mailMessageArg = ArgumentCaptor.forClass(SimpleMailMessage.class);
    verify(mockMailSender, times(2)).send(mailMessageArg.capture());
    List<SimpleMailMessage> mailMessages = mailMessageArg.getAllValues();
    assertThat(mailMessages.get(0).getTo()[0], is(users.get(1).getEmail()));
    assertThat(mailMessages.get(1).getTo()[0], is(users.get(3).getEmail()));
}
```

### 6.3 다이내믹 프록시와 팩토리 빈
---
#### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴  
트랜잭션 기능은 사용자 관리 비즈니스 로직과는 성격이 다르기 때문에 아예 적용 사실 자체를 밖으로 분리할 수 있다.  
이렇게 분리된 부가기능을 담은 클래스는 부가 기능 외의 나머지 모든 기능은 원래 핵심 기능을 가진 클래스로 위임해줘야 한다. **부가기능이 핵심기능을 사용하는 구조**  

클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고, 부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야 한다.  

부가기능 코드에서는 핵심기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인 기능을 적용해줄 수 있다. (비즈니스 로직 코드에 트랜잭션 기능 부여)

위와 같이 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 `프록시`라고 부른다. 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트는 `타깃`, 또는 `실체`라고 부른다.  

* 프록시의 특징
    > 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있다는 위치에 있다.

* 사용 목적에 따른 구분
    1. 클라이언트가 타깃에 접근하는 방법 제어
    2. 타깃에 부가적인 기능 부여  


**데코레이터 패턴**
> 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴

컴파일 시점, 즉 코드 상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있기 때문에 데코레이터패턴에서는 프록시가 꼭 한 개로 제한되지 않는다.   
데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있다. 프록시가 여러 개인 만큼 순서를 정해서 단계적으로 위임하는 구조로 만들면 된다.  

프록시로 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때무에 자신이 최종 타깃으로 위임하는지, 다음 단게의 데코레이터 프록시로 위임하는지 알지 못한다. 따라서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임시에 주입받을 수 있도록 만들어야 한다. 

인터페이스를 통한 데코레이터 정의와 런타임 시의 다이내믹한 구성 방법은 스프링의 DI를 이용하여 데코레이터 빈의 프로퍼티로 같은 인터페이스를 구현한 다른 데코레이터 또는 타깃 빈을 설정하면 된다.  

데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용하다.  

**프록시 패턴**
> * 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우 
> * 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용

프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.  
* 프록시를 사용하는 경우
    1. 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는 경우  
    : 실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨 준다.  
    2. 원격 오브젝트를 이용하는 경우  
    : 다른 서버에 존재하는 오브젝트를 사용해야 한다면, 원격 오브젝트에 대한 프록시를 만들어두고, 클라이언트는 로컬에 존재하는 오브젝트를 쓰는 것처럼 프록시를 사용하게 할 수 있다.  
    3. 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위해 사용  
    : 예를 들어 수정 가능한 오브젝트가 있는데, 특정 레이어로 넘어가서는 읽기 전용으로만 동작하게 강제해야 할 때 오브젝트의 프록시를 만들어서 사용할 수 있다.  

프록시와 데코레이터는 유사한 구조이지만, 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.  

#### 6.3.2 다이내믹 프록시
**프록시의 구성과 프록시 작성의 문제점**  
* 프록시의 기능
    - 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다.
    - 지정된 요청에 대해서는 부가기능을 수행한다. 

* 프록시의 역할
    - 위임
    - 부가작업

* 프록시를 만들기 번거로운 이유
    - 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 번거롭다.
    - 부가기능 코드가 중복될 가능성이 많다.  

**리플렉션**  
다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다. 리플랙션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.  
클래스 오브젝트를 이용하면 클래스 코드에 대한 메타정보를 가져오거나 오브젝트를 조작할 수 있다. (java.lang.reflect)

**프록시 클래스**
1. Hello 인터페이스 정의
2. 인터페이스를 구현한 타깃 클래스
3. Hello 인터페이스를 통해 HelloTarget 오브젝트를 사용하는 클라이언트(테스트)  
4. Hello 인터페이스를 구현한 프록시 : 데코레이터 패턴 적용해 부가기능 추가  
    -> HelloUppercase  
Hello 인터페이스 구현 메소드에서는 타깃 오브젝트의 메소드를 호출한 뒤 결과를 대문자로 바꿔주는 부가기능을 적용하고 리턴한다.  

이 프록시는 인터페이스의 모든 메소드를 구현해 위임하도록 코드를 만들어야 하며, 부가 기능인 리턴 값을 대문자로 바꾸는 기능이 모든 메소드에 중볻돼서 나타난다는 문제점을 갖고 있다.

**다이내믹 프록시 적용**  
다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다.  
다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어진다.  
클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다.  
프록시 팩토리에게 인터페이스 정보만 제공하면 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어 준다.   

부가기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담는다. invoke()는 리플렉션의 Method 인터페이스를 파라미터로 받는다.  
다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의 invoke() 메소드로 넘긴다.  
타깃 인터페이스의 모든 메소드 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.  


다이내믹 프록시로부터 요청을 전달받으려면 **InvocationHandler**를 구현해야 한다. 
* 메소드는 invoke() 하나뿐이다. 다이내믹 프록시가 클라이언트로부터 받는 모든 요청은 invoke()로 전달된다. 
* 다이내믹 프록시를 통해 요청이 전달되면 리플렉션 API를 이용해 타깃 오브젝트의 메소드를 호출한다. 
* 타깃 오브젝트는 생성자를 통해 미리 전달받아 둔다.  
* 타깃 오브젝트의 메소드 호출이 끝나면 프록시가 제공하려는 부가기능을 수행하고 리턴한다.  

InvocationHandler를 사용하고 Hello 인터페이스를 구현하는 **프록시 생성**  
* 다이내믹 프록시 생성은 Proxy 클래스의 newProxyInstance() 스태택 팩토리 메소드 이용 
* newProxyInstance()에 의해 만들어지는 다이내믹 프록시 오브젝트는 파라미터로 제공한 Hello 인터페이스를 구현한 클래스의 오브젝트이기 때문에 Hello 타입으로 캐스팅이 가능하다. 

**다이내믹 프록시의 확장**
InvocationHandler 방식의 또 한 가지 장점은 타깃의 종류에 상관없이도 적용이 가능하다. 리플렉션의 Method 인터페이스를 이용해 타깃의 메소드를 호출하므로 Hello 타입의 타깃으로 제한할 필요도 없다.  
InvocationHandler는 단일 메소드에서 모든 요청을 처리하기 때문에 어던 메소드에 어떤 기능을 적용할지 선택하는 과정이 필요할 수도 있다.   

#### 6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능  
UserServiceTx는 트랜잭션이 필요한 메소드마다 트랜잭션 처리가 중복되는데 다이내믹 프록시와 연동하면 InvocationHandler 한 개만 정의해도 된다.  

**트랜잭션 InvocationHandler**  
요청을 위임할 타깃을 DI로 제공받는다. 타깃을 저장할 변수는 Object로 선언한다. 따라서 UserServiceImpl 외에 트랜잭션 적용이 필요한 어떤 타깃 오브젝트에도 적용할 수 있다. 트랜잭션 추상화 인터페이스를 DI 받고 트랜잭션을 적용할 메소드 이름의 패턴을 DI 받는다. (ex. get : get으로 시작하는 모든 메소드)  
InvocationHandler의 invoke() 구현은 적용할 대상을 선별해서 DI 받은 이름과 패턴으로 시작되는 이름을 가진 메소드인지 확인한다.  
차이점은 롤백을 적용하기 위해 RuntimeExcetpion이 아닌  InvocationTargetException을 잡도록 해야 한다.   

**TransactionHandler와 다이내믹 프록시를 이용하는 테스트**  
UserServiceTx 오브젝트 대신 TransactionHandler를 만들고 타깃 오브젝트와 트랜잭션 매니저, 메소드 패턴을 주입해준다.  

#### 6.3.4 다이내믹 프록시를 위한 팩토리 빈  
DI 대상이 되는 다이내믹 프록시 오브젝트는 일반적인 스프링 빈으로 등록할 수 없다.  
스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해 해당 클래스의 오브젝트를 만든다.  
스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성한다. 하지만 다이내믹 프록시 오브젝트는 이런 식으로 프록시 오브젝트가 생성되지 않는다. _다이내믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다._  

**팩토리 빈**  
> 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈 
스프링의 FactoryBean이라는 인터페이스를 구현하는 방법이 가장 간단하다.  
FactoryBean 인터페이스를 구현한 클래스를 스프링 빈으로 등록하면 팩토리 빈으로 등록한다.   

스프링에서 빈 오브젝트로 만들어 사용하고 싶은 클래스의 메소드는 반드시 스태틱 메소드를 사용해야 한다.  
스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해 오브젝트를 만들어주지만 권장되지 않으며 바르게 동작하지 않을 가능성도 있다.  

팩토리 빈은 전형적인 팩토리 메소드를 가진 오브젝트다. 스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면, 팩토리 빈 클래스의 오브젝트의 getObject() 메소드를 이용해 오브젝트를 가져오고, 이를 빈 오브젝트로 사용한다. 빈의 클래스로 등록된 팱토리 빈은 빈 오브젝트를 생성하는 과정에서만 사용된다.  

**팩토리 빈의 설정 방법**  
id와 class 애트리뷰트를 사용해 빈의 아이디와 클래스를 지정하는 것은 동일하지만, message 빈 오브젝트의 타입이 Message 타입니다.  
Message 빈의 타입은 MessageFactoryBean의 getObjectType() 메소드가 돌려주는 타입으로 결정된다. 또, getObject() 메소드가 생성해주는 오브젝트가 message 빈의 오브젝트가 된다.  

**다이내믹 프록시를 만들어주는 팩토리 빈**  
팩토리 빈을 사용하면 다이내믹 프록시 오브젝트를 스츠링의 빈으로 만들어 줄 수 있다. 팩토리 빈의 getObject()에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 되기 때문이다.  
스프링 빈에는 팩토리 빈과 UserServiceImpl만 빈으로 등록한다. 팩토리 빈은 다이내믹 프록시가 위임할 타깃 오브젝트인 UserServiceImpl에 대한 레퍼런스를 프로퍼티를 통해 DI 받아둬야 한다. 다이내믹 프록시와 함께 생성할 TransactionHandler에게 타깃 오브젝트를 전달해줘야 하기 때문이다.  

**트랜잭션 프록시 팩토리 빈**  
팩토리 빈이 만드는 다이내믹 프록시는 구현 인터페이스나 타깃의 종류에는 제한이 없기 때문에 UserService 외에도 트랜잭션 부가기능이 필요한 오브젝트를 위한 프록시를 만들 때 재사용이 가능하다. 설정이 다른 여러 TxProxyFacgtoryBean을 등록하면 된다.   

**트랜잭션 프록시 팩토리 빈 테스트**  
TxProxyFactoryBean의 트랜잭션을 지원하는 프록시를 바르게 만들어주는지 확인하는 게 목적이므로 빈으로 등록된 TxProxyFactoryBean을 직접 가져와서 프록시를 만들어보면 된다.   
TxProxyFactoryBean은 계속 재사용할 수 있다. 트랜잭션 부가기능이 필요한 빈이 추가될 때마다 빈 설정만 추가해주면 된다.  

#### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계
**프록시 팩토리 빈의 재사용**  
TxProxyFactoryBean은 코드 수정 없이 다양한 클래스에 적용할 수 있다.  
하나의 TxProxyFactoryBean을 동시에 빈으로 등록해도 상관없다.  

UserService 외에 트랜잭션 경계설정 기능을 부여해줄 필요가 있는 필요한 클래스가 있다면, 인터페이스(CoreService)에 정의된 수십 여개의 메소드에 트랜잭션을 모두 적용해야 한다.  
CoreService 빈에 트랜잭션 기능이 필요해지면 UserService에 적용하느라 만들었던 TxProxyFactoryBean을 그대로 적용해주면 된다.  
traget 프로퍼티를 coreServiceTarget 빈으로 설정해주고 serviceInterface에는 프록시가 구현할 인터페이스이 CoreService를 넣어주면 된다. CoreService 인터페이스에 정의된 모든 메소드에 트랜잭션 기능을 적용하려면 pattern 값을 빈 문자열로 설정해주면 된다. 

**프록시 팩토리 빈 방식의 장점**  
* 프록시를 활용하지 못하는 두 가지 문제점
    - 프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는 프록시 클래스를 일일이 만들어야 한다는 번거로움  
    - 부가적인 기능이 여러 메소드에 반복적으로 나타나는 코드 중복  

다이내믹 프록시를 이용하면 타깃 인터페이스를 구현하는 클래스를 일일이 만들지 않아도 된다. 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소드에 부가기능을 부여해 줄 수 있으므로 부가 기능 코드의 중복 문제도 사라진다. 다이내믹 프록시에 팩토리 빈을 이용한 DI 까지 더해주면 다이내믹 프록시 생성 코드도 제거할 수 있다. DI 설정만으로 다양한 타깃 오브젝트에 적용도 가능하다.  

**프록시 팩토리 빈의 한계**  
프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일이다. 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 불가능하다.  
하나의 타깃에 여러 개의 부가기능을 적용하려고 할 때도 문제이다. XML 설정이 매우 길어지기 때문이다.  
또다른 문제점은 TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어진다. 


### 6.4 스프링의 프록시 팩토리 빈
---
#### 6.4.1 ProxyFactoryBean
스프링의 ProxyFactoryBean은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다.  
ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있다.  
ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.  
InvocationHandler와 다르게 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지 함께 제공받기 때문에 타깃 오브젝트에 상관없이 독립적으로 만들어 질 수 있다.   따라서 MethodInterceptor 오브젝트는 타깃이 다른 여러 프록시에서 함께 사용할 수 있고, 싱글톤 빈으로 등록 가능하다.  

**어드바이스: 타깃이 필요 없는 순수한 부가기능**  
MethodInterceptor로는 메소드 정보와 함께 타깃 오브젝트가 담긴 MethodInterception 오브젝트가 전달된다. MethodInterception은 타깃 오브젝트의 메소드를 실행할 수 있는 기능이 있기 때문에 MethodInterceptor는 부가기능을 제공하는 데만 집중할 수 있다.  
MethodInterception은 콜백 오브젝트의 일종으로, proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주어 구현 클래스는 일종의 템플릿처럼 동작한다.  
ProxyFactoryBean은 템플릿 역할을 하는 MethodInterception을 싱글톤으로 두고 공유할 수 있다.  
ProxyFactoryBean에는 여러 개의 MethodInterceptor를 추가할 수 있다. ProxyFactoryBean 하나만으로 여러 개의 프록시를 만들 수 있다는 뜻이다.  

MethodInterceptor는 Adivice 인터페이스를 상속하고 있는 서브 인터페이스이다.  
> **_어드바이스란?_** 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트

또한 ProxyFactoryBean에는 인터페이스 자동검출 기능이 있어 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아내 알아낸 인터페이스를 모두 구현하는 프록시를 만든다.  
타깃 오브젝트가 구현하는 인터페이스 중에서 일부만 프록시에 적용하고 싶다면 인터페이스 정보를 직접 제공할 수도 있다.  


**포인트컷: 부가기능 적용 대상 메소드 선정 방법**  
MethodInterceptor 오브젝트는 여러 프록시가 공유해서 사용할 수 있도록 타깃 정보를 가지고 있지 않다.  
하지만 트랜잭션 적용 메소드 패턴은 프록시마다 다를 수 있기 때문에 특정 프록시에만 적용되는 패턴을 넣으면 문제가 된다.  

이 문제를 해결하기 위해서 MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남기고, 프록시에서 부가기능 적용 메소드를 선택하는 기능을 넣으면 된다.  
프록시의 핵심가치는 타깃을 대신해서 클라이언트의 요청을 받아 처리하는 오브젝트로서의 존재 자체이므로, 메소드를 선정하는 일은 프록시에서 분리해야 한다. 메소드 선정도 교환 가능한 알고리즘이므로 전략 패턴을 적용할 수 있다.  

> **_포인트 컷이란?_** 메소드 선정 알고리즘을 담은 오브젝트  

<br>
어드바이스와 포인트 컷은 모두 프록시에 DI로 주입돼서 사용된다.   

두 가지 모두 여러 프록시에서 공유가 가능하도록 만들어지기 때문에 스프링의 싱글톤 빈으로 등록이 가능하다.  
프록시는 클라이언트로부터 요청을 받으면 먼저 포인트컷에게 부가기능을 부여할 메소드인지를 확인해달라고 요청한다.  
프록시는 포인트컷으로부터 부가기능을 적용할 대상 메소드인지 확인받으면 MethodInterceptor 타입의 어드바이스를 호출한다. 어드바이스는 자신이 공유돼야하므로 타깃 정보라는 상태를 가질 수 없기 때문에 타깃에 직접 의존하지 않도록 템플릿 구조로 설계되어 있다.  
어드바이스가 부가기능을 부여하는 중에 타깃 메소드의 호출이 필요하면 프록시로부터 전달받은 MethodInvocation 타입 콜백 오브젝트의 proceed() 메소드를 호출하면 된다.  
프록시가 메소드 호출에 따라 만드는 **Invocation 콜백의 역할**은 가지고 있는 실제 위임 대상인 타깃 오브젝트의 레퍼런스를 이용해 **타깃 메소드를 직접 호출**하는 것.  
어드바이스가 일종의 템플릿이되고 타깃을 호출하는 기능을 갖고 있는 MethodInvocation 오브젝트가 콜백이 되는 것이다.  

프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 한 것은 전형적인 전략 패턴 구조이기 때문에 여러 프록시가 공유해서 사용할 수도 있고, 구체적인 부가기능 방식이나 메소드 선정 알고리즘이 바뀌면 구현 클래스만 바꿔서 설정에 넣어주면 된다.  

포인트 것을 함께 등록할 때는 어드바이스와 포인트컷을 Advisor 타입으로 묶어서 addAdvisor() 메소드를 호출해야 한다. ProxyFactoryBean에는 여러 개의 어드바이스와 포인트컷이 추가될 수 있기 때문이다.  
여러 개의 어드바이스가 등록되더라도 각각 다른 포인트컷과 조합될 수 있기 때문에 각기 다른 메소드 선정 방식을 적용할 수 있다.

> **어드바이저 = 포인트컷(메소드 선정 알고리즘) + 어드바이스(부가기능)**

#### 6.4.2 ProxyFactoryBean 적용
**TransactionAdvice**   
부가기능을 담당하는 어드바이스는 MethodInterceptor라는 Advice 서브 인터페이스를 구현해서 만든다.
```java
    public class TransactionAdvice implements MethodInterceptor{
        PlatformTransactionManager transactionManager;
        public void setTransactionManager(PlatformTransactionManager transactionManager){
            this.transactionManager =transactionManager;
        }
        public Object invoke(MethodInvocation invocation) throws Throwable {
            TransactionStatus status = this .transactionManager .getTransaction(new DefaultTransactionDefinition());

            try{
                // 콜백을 이용해 타깃 메소드 호출 작업을 제거할 수 있다.
                Object ret = invocation.proceed();
                this.transactionManager.commit(status);
                return ret;
            } catch (RuntimeException e){
                this.transactionManager.rollback(status);
                throw e;
            }
        } 
    }
```
**스프링 XML 설정파일**  
1. 어드바이스 등록 (트랜잭션 기능을 적용을 위해 transactionManager만 DI 해주면 된다.) 
2. 포인트컷 빈 등록 (트랜잭션 적용 메소드 선정을 위해. 메소드 이름 패턴은 upgrade*)
3. 어드바이스와 포인트컷을 담을 어드바이저 빈 등록
4. ProxyFactoryBean 등록 (프로퍼티에 타깃 빈과 어드바이저 빈 지정)

**테스트**  
트랜잭션이 적용됐는지 확인하는 테스트는 예외 상황을 강제로 만들어서 테스트하는데, 이도 스프링의 ProxyFactoryBean도 팩토리 빈이므로 기존의 TxProxyFactoryBean과 같은 방법으로 테스트할 수 있다. 팩토리 빈을 가져올 때 캐스팅할 타입만 ProxyFactoryBean으로 간단히 변경해주면 된다.  

**어드바이스와 포인트컷의 재사용**  
ProxyFactoryBean은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용되어 있어 독립적이며, 여러 프로시가 공유할 수 있는 어드바이스와 포인트컷으로 확장 기능을 분리할 수 있다.  
트랜잭션 부가기능을 담은 TransactionAdvice는 하나만 만들어서 싱글톤 빈으로 등록하면 DI 설정을 통해 모든 서비스에 적용이 가능하다. 메소드 선정 방식이 달라지는 경우에만 포인트컷의 설정을 따로 등록하고 어드바이저로 조합해서 적용해주면 된다.  


### 6.5 스프링 AOP
---
#### 6.5.1 자동 프록시 생성  
프록시 팩토리 빈 방식의 접근 방법의 한계 중 부가 기능 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정 정보를 추가해주는 문제가 남아 있다.  

**중복 문제의 접근 방법**  
반복적인 위임 코드가 필요한 프록시 클래스 코드는 다이내믹 프록시라는 런타임 코드 자동 생성 기법을 이용해 특정 인터페이스를 구현한 오브젝트에 대해 프록시 역할을 해주는 클래스를 런타임 시 내부적으로 만들어준다.  
변하지 않는 타깃으로의 위임과 부가기능 적용 여부 판단 부분은 코드 생성 기법을 이용하는 다이내믹 프록시 기술에 맡기고, 변하는 부가기능 코드는 별도로 만들어서 다이내믹 프록시 생성 팩토리에 DI로 제공하는 방법을 사용한다.  
반복적인 ProxyFactoryBean 설정 문제는 일정한 타깃 빈 목록을 제공하면 자동으로 각 타깃 빈에 대한 프록시를 만들어주는 설정 자동 등록 기법이 있다.  

**빈 후처리기를 이용한 자동 프록시 생성기**  
스프링은 컨테이너로서 제공하는 기능 중에 변하지 않는 핵심적인 부분 외에는 대부분 확장할 수 있도록 **확장 포인트**를 제공해준다.   
그 중에서 BeanPostProcessor 인터페이스를 구현해서 만드는 빈 후처리기라는 확장 포인트가 있다.  
**빈 후처리기**는 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다.  

DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기이다. 빈 푸러치기를 빈으로 등록하면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다.  
이를 잘 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수도 있다.  

빈 후처리기를 이용한 자동 프록시 생성 방법  
* DefaultAdvisorAutoProxyCreator 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들때마다 후처리기에 빈을 보낸다.
* DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
* 프록시 적용 대상이면 내장된 프록시 싱성기에 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결한다. 
* 프록시가 생성되면 프록시 오브젝트를 컨테이너에 돌려준다.
* 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.  

**확장돤 포인트컷**
* 포인트 컷의 두 가지 기능
    - 메소드만 선별하는 기능 : 클래스 필터가 모든 클래스를 다 받아주도록 만들어짐.
    - 빈 오브젝트 자체를 선택하는 기능   
    : 프록시를 적용할 클래스인지 판단하고 나서 적용 대상 클래스인 경우에는 어드바이스를 적용할 메소드인지 확인하는 방식으로 동작.

**포인트컷 테스트**  
테스트는 세가지 클래스에 대해 진행한다.  
세 개의 클래스에 모두 동일한 포인트컷을 적용한다.  
세 개의 클래스를 포인트컷을 적용할 타깃 오브젝트로 각각 등록하고, 각 메소드에 대해 어드바이스 적용 여부를 확인한다.  

#### 6.5.2 DefaultAdvisorAutoProxyCreator의 적용
**클래스 필터를 적용한 포인트컷 작성**   
만들어야할 클래스는 메소드 이름만 비교하던 포인트컷인 NameMatchMethodPointcut을 상속해서 프로퍼티로 주어진 이름 패턴을 가지고 클래스 이름을 비교하는 ClassFilter를 추가하도록 하는 클래스 하나이다.  

**어드바이저를 이용하는 자동 프록시 생성기 등록**  
적용할 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator는 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾고 생성되는 모든 빈에 대해 어드바이저의 포인터컷을 적용해보면서 프록시 적용 대상을 선정한다. 빈 클래스가 프록시 선정 대상이면 프록시를 만들어 원래 빈 오브젝트와 바꿔치기해서 타깃 빈에 의존한다고 정의한 다른 빈들은 프록시 오브젝트를 대신 DI 받게 된다.  

**포인트컷 등록**  
새로 만든 클래스 필터 지원 포인트컷을 빈으로 등록한다.  

**어드바이스와 어드바이저**  
어드바이저를 이용하는 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator에 의해 자동 수집되고, 프록시 대상 선정 과정에 참여하며, 자동생성된 프로시에 다이내믹하게 DI 돼서 동작하는 어드바이저가 된다.  

**ProxyFactoryBean 제거와 서비스 빈의 원상복구**  
명시적인 프록시 팩토리 빈을 등록하지 않기 때문에 ProxyFactoryBean 타입의 빈은 삭제한다. 

**자동 프록시 생성기를 사용하는 테스트**  
@Autowired를 통해 컨텍스트에서 가져오는 UserService 타입 오브젝트는 트랜잭션이 적용된 프록시여야 한다.  
스프링 컨테이너 종속적인 자동 프록시 생성기를 적용한 후에는 더 이상 가져올 ProxyFactoryBean 같은 팩토리 빈이 존재하지 않기 때문에 예외 상황을 위한 테스트 대상도 빈으로 등록해줄 필요가 있다.  
기존에 만들었던 강제 예외 발생용 TestUserService 클래스를 빈으로 등록해야 하는데, TestUserService가 스태틱 클래스라는 점과 포인트컷이 트랜잭션 어드바이스를 적용해주는 대상 클래스의 이름 패턴이 *ServiceImpl이라고 되어 있어 TestUserService 클래스는 빈으로 등록해도 프록시 적용 대상으로 선정해주지 않는다.  

문제 해결 방법  
1. TestUserServiceImpl로 이름 수정
2. 테스트 코드에서 생성하는 것이기 아니기 때문에 테스트 픽스처로 만든 users 리스트에서 예외를 발생시킬 기준 id를 사용할 방법이 없으므로 예외를 발생시킬 대상인 네번째 사용자 아이디를 클래스에 넣는다.  

TestUserServiceImpl을 빈으로 등록한다.  
TestUserServiceImpl 클래스는 UserServiceTest의 스태틱 멤버 클래스이므로 $를 사용해서 클래스 이름을 지정해주면 된다. 또 `<bean>` 태그에 parent 애트리뷰트를 사용하면 다른 빈 설정의 내용을 상속받을 수 있다. testUserService는 userService 빈의 설정을 상속받은 뒤 클래스만 변경했으므로 `parent="userService"`라고 설정하면 된다.   

마지막으로 upgradeAllOrNothing() 테스트를 새로 추가한 testUserService 빈을 사용하도록 수정한다. 테스트 코드에서 예외 상황을 적용하기 위한 DI 작업이 제거되어 코드가 단순해졌다.  

**자동생성 프록시 확인**  
확인해야 할 것
* 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용됐는가  
    => upgradeAllOrNothing()으로 검증
* 아무 빈에나 트랜잭션 부가기능이 적용된 것은 아닌지 확인 필요
    => 포인트컷 빈의 클래스 이름 패턴을 변경해서 testUserService 빈에 트랜잭션이 적용되지 않으면 됨

컨테이너가 돌려준 서비스 빈의 타입을 확인하는 코드로 자동생성된 프록시를 확인할 수도 있다.  
```java
@Test
public void advisorAutoProxyCreator() {
    assertThat(testUserService, is(java.lang.reflect.Proxy.class));
}
```

#### 6.5.3 포인트컷 표현식을 이용한 포인트컷
**포인트컷 표현식**  
복잡하고 세밀한 기준을 이용해 클래스나 메소드를 선정해야 할 때 정규식처럼 표현식 언어를 사용해 포인트컷을 작성할 수 있도록 하는 방법 (AspectJExpressionPointcut 클래스를 사용)   
스프링이 사용하는 포인트컷 표현식은 AspectJ라는 프레임워크에서 제공하는 것을 가져와 일부 문법을 확장해서 사용한다.  

**포인트컷 표현식 문법**  
AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성한다.   
`
execution([접근제한지 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...) [throws 예외 패턴])
`
ex)
```
System.out.println(Target.class.getMethod("minus", int.class, int.class));

//결과
public int springbook.learningtest.spring.pointcut.Target.minus(int, int) throws java.lang.RuntimeException
```
* **public**  
    접근제한자. 생략 가능  
* **int**  
    리턴 값의 타입을 나타내는 패턴. (*도 가능)  
* **springbook.learningtest.spring.poincut.Target**  
    패키지와 타입이름을 포함한 클래스의 타입 패턴. 생략하면 모든 타입 허용.  
    메소드 이름 패턴과 `.`으로 연결됨. 패키지 이름과 클래스 또는 인터페이스명에 `*`를 사용할 수 있으며 `..`를 사용하면 한 번에 여러 패키지 선택 가능   
* **minus**  
    메소드 이름 패턴. 필수 항목. 모든 메소드는 `*`
* **(int, int)**  
    메소드 파라미터 타입 패턴. `.`로 구분하면서 순서대로 적으면 된다. 필수항목.  
    파라미터가 없는 메소드는 `()`    
    파라미터 타입, 개수에 상관없으려면 `..`    
    뒷부분 파라미터 조건만 생략하려면 `...`  
* **throws java.lang.RuntimeException**  
    예외 이름에 대한 타입 패턴. 생략 가능

**포인트컷 표현식 테스트**  
**포인트컷 표현식을 이용하는 포인트컷 적용**  
execution() 외에도 빈의 이름으로 비교하는 bean(), 특정 애노테이션이 타입, 메소드, 파라미터에 적용되어 있는 것을 보고 메소드를 선정하게 하는 포인트컷도 만들 수 있다.  
단점은 문자열로 된 표현식이므로 런타임 시점까지 문법의 검증이나 기능 확인이 되지 않는다는 것이다.  

**타입 패턴과 클래스 이름 패턴**  
포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 타입패턴이다.  
TestUserService의 클래스 이름은 TestUserService일 뿐이지만, 타입을 따져보면 TestUserService 클래스이자, 슈퍼클래스인 UserServiceImpl, 구현 인터페이스인 UserService 세 가지가 모두 적용되기 때문에 타입 패턴의 조건을 충족한다.  

#### 6.5.4 AOP란 무엇인가?
**트랜잭션 서비스 추상화**   
트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법을 적용했다.  
구체적인 구현 내용을 담은 의존 오브젝트는 런타임 시 다이내믹하게 연결해주는 DI를 활용한 방법이다.    

**프록시와 데코레이터 패턴**  
트랜잭션은 거의 대부분의 비즈니스 로직을 담은 메소드에 필요하다. 그리고 트랜잭션의 경계 설정을 담당하는 코드의 특성 때문에 단순한 추상화와 메소드 추출 방법으로 제거할 수 없어서 DI를 이용해 데코레이터 패턴을 적용했다.  
클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고, 데코레이터 패턴을 적용해서, 비즈니스 로직을 담은 클래스의 코드에는 전혀 영향을 주지 않고 트랜잭션을 부여할 수 있다.  
클라이언트가 일종의 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃에 접근하게 된다.  

**다이내믹 프록시와 프록시 팩토리 빈**  
비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하게 되면서 프록시 클래스를 만드는 작업이 복잡해졌다.  
그래서 프록시 클래스 없이 프록시 오브젝트를 런타임시에 만들어주는 JDK 다이내믹 프록시 기술을 적용했다. 중복 문제가 일부 해결됐고, 메소드 선정 패턴 등을 이용할 수도 있었다.  
하지만 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로 중복이 일어나는 문제는 여전히 남아 있다.  

JDK 다이내믹 프록시 같은 프록시 기술을 추상화한 스프링 프록시 팩토리 빈(템플릿/콜백 패턴 활용)을 이용해서 다이내믹 프록시 생성 방법에 DI를 도입해 어드바이스와 포인트컷이 프록시에서 분리될 수 있었고, 여러 프록시에서 공유해서 사용할 수 있게 되었다.  

**자동 프록시 생성 방법과 포인트컷**   
트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해야 하는 문제를 해결하기 위해서 **스프링 컨테이너의 빈 생성 후처리 기법**을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다. 클래스를 선정하는 기능을 담은 확장된 포인트컷을 사용했다. (포인트컷 표현식)  

**부가기능의 모듈화**   
트랜잭션 경계설정 기능은 다른 모듈의 코드에 부가적으로 부여되는 기능이기 때문에 간단하게 분리하기 어려웠다. 부가 기능이기 때문에 독립적인 방식으로 존재해서는 적용되기 어렵기 때문이다.  
따라서 클래스를 만들지 않고 새로운 구현 기능을 가진 오브젝트를 다이내믹하게 만들어내는 다이내믹 프록시나, IoC/DI 컨테이너의 빈 생성 작업을 가로채서 빈 오브젝트를 프로시로 대체하는 빈 후처리 기술과 같은 기술이 요구된다.  

어드바이스와 포인트컷을 결합한 **어드바이저**가 핵심기능에 부여되는 부가기능을 효과적으로 모듈화 하는 방법이다.  

**AOP: 애스펙트 지향 프로그래밍**  
부가기능 모듈을 객체지향 기술에서 주로 사용하는 오브젝트와는 다르게 부르는 것이 **aspect**이다. 애스팩트란 그 자체로 어플리케이션의 핵심기능을 담고 있지는 않지만, 어플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가리킨다.  

**애스팩트 지향 프로그래밍(AOP)**이란 어플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법이다. AOP는 OOP를 돕는 보조적인 기술일 뿐, OOP를 완전히 대체하는 새로운 개념은 아니다.  
AOP는 애스펙트를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 것이다.  

#### 6.5.5 AOP 적용기술
**프록시를 이용한 AOP**  
프록시로 만들어서 DI로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해서 부가기능을 제공하도록 만들었다.  
스프링 AOP의 부가기능을 담은 어드바이스가 적용되는 대상은 오브젝트의 메소드이다. 어드바이스가 구현하는 MethodInterceptor 인터페이스는 프록시로부터 메소드 요청정보를 전달받아 타깃 오브젝트의 메소드를 호출하는데, 메소드 호출 전후에 다양한 부가 기능을 제공할 수 있다.  
프록시는 독립적으로 개발한 부가 기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해 주기 위한 가장 중요한 역할을 맏고 있다.  
> 스프링 AOP는 프록시 방식의 AOP

**바이트코드 생성과 조작을 통한 AOP**   
AspectJ는 스프링처럼 다이내믹 프록시 방식을 사용하지 않는다.  
AspectJ는 타깃 오브젝트를 뜯어고쳐서 부가 기능을 직접 넣어주는 직접적인 방식을 사용한다.  
컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 방법을 사용한다.    

* 바이트코드를 조작해 타깃 오브젝트를 직접 수정하면 자동 프록시 생성 방식을 사용하지 않아도 AOP 적용 가능  
* 프록시보다 강력하고 유연한 AOP가 가능하다.   

#### 6.5.6 AOP의 용어
* **타깃**  
    : 부가 기능을 부여할 대상 (핵심기능을 담은 클래스 / 부가기능을 제공하는 프록시 오브젝트)
* **어드바이스**
    : 타깃에게 제공할 부가기능을 담은 모듈  
* **조인 포인트**  
    : 어드바이스가 저용될 수 있는 위치. 스프링의 프록시 AOP에서는 메소드의 실행 단계.
* **포인트컷**  
    : 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈  
    포인트 컷의 표현식은 execution으로 시작하고, 메소드의 시그니처를 비교하는 방법을 주로 이용함.  
* **프록시**  
    : 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트.  
    DI를 통해 타깃 대신 클라이언트에 주입되며, 클라이언트의 메소드 호출을 대신 받아 타깃에 위임해주면서, 부가기능을 부여한다.  
* **어드바이저**  
    : 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트.  
    어떤 부가기능`(어드바이스)`을 어디에`(포인트컷)` 전달할 것인가를 알고 있는 AOP의 가장 기본이되는 모듈. 스프링 AOP에서만 사용되는 용어.  
* **애스펙트**  
    : 애스펙트는 AOP의 기본 모듈이다.  
    한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다.  

#### 6.5.7 AOP 네임스페이스
스프링의 프록시 방식 AOP를 적용하려면 최소 네 가지 빈을 등록해야 한다.  
* **자동 프록시 생성기**  
    : 스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다.  
    어플리케이션 컨텍스트가 빈 오브젝트를 생성하는 과정에 빈 후처리기로 참여한다.  
    빈으로 등록된 어드바이저를 이용해 프록시를 자동으로 생성하는 기능을 담당한다.  
* **어드바이스**  
    : 부가기능을 구현한 클래스를 빈으로 등록한다.  
    TransactionAdvice는 AOP 관련 빈 중에서 유일하게 직접 구현한 클래스를 사용한다.  
* **포인트컷**  
    : 스프링의 AspectJExpressionPointcut을 빈으로 등록하고 expression 프로퍼티에 포인트컷 표현식을 넣어주면 된다.  
* **어드바이저**  
    : 스프링의 DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용한다.  
    어드바이스와 포인트컷을 프로퍼티로 참조하는 것 외에 기능은 없다.  

어드바이스를 제외한 나머지는 모두 스프링이 직접 제공하는 클래스를 빈으로 등록하고 프로퍼티 설정만 해준 것이다.  

**AOP 네임스페이스**  
AOP를 위해 기계적으로 적용하는 빈들을 위해 AOP와 관련된 태그를 정의해둔 aop 스키마를 제공한다. aop 스키마에 정의된 태그는 별도의 네임스페이스를 지정해서 디폴트 네입스페이스의 `<bean>` 태그와 구분해서 사용할 수 있다.  
```xml
<aop:config>
    <aop:pointcut id="transactionPointcut" expression="execution(* *..*ServiceImpl.upgrade*(..))" />
    <aop:advisor advice-ref="transactionAdvice" pointcut-ref="transactionPointcut" />
</aop:config>
```
세 가지 태그를 정의해두면 세 개의 빈이 자동으로 등록된다.  

**어드바이저 내장 포인트컷**  
포인트컷 표현식을 활용하는 포인트컷은 스트링으로 된 표현식을 담은 expression 프로퍼티 하나만 설정해주면 사용할 수 있다. 또한 포인트컷은 어드바이저에 참조되어야만 사용된다.  
포인트컷을 내장하는 경우에는 `<aop:advisor>` 태그 하나로 어트리뷰트 설정에 따라 등록되는 빈의 개수와 종류가 달라질 수 있다.  


### 6.6 트랜잭션 속성
---
#### 6.6.1 트랜잭션 정의  
> 트랜잭션 : 더 이상 쪼갤 수 없는 최소 단위의 작업

commit() rollback() 외에 트랜잭션의 동작방식을 제어할 수 있는 조건이 있다.   
(DefaultTransactionDefinition이 구현하고 있는 TransactionDefinition 인터페이스에서 정의하고 있는 네 가지 속성)  

**트랜잭션 전파**  
(transaction propagation) 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식  
독자적인 트랜잭션 경계를 가진 코드에 대해 이미 진행 중인 트랜잭션이 어떻게 영향을 미칠 수 있는 갓을 정의하는 것이 트랜잭션 전파 속성이다.  
* **PROPAGATION_REQUIRED**  
진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여한다.  
A와 B가 모두 PROPAGATION_REQUIRED로 선언되어 있다면, `A`, `B`, `A->B`, `B->A`와 같은 네 가지의 조합된 트랜잭션이 모두 가능하다.  

* **PROPAGATION_REQUIRES_NEW**  
항상 새로운 트랜잭션을 시작한다. 새로운 트랜잭션을 만들어서 독자적으로 동작하게 한다. 독립적인 트랜잭션이 보장돼야 하는 코드에 적용할 수 있다.  

* **PROPAGATION_NOT_SUPPORTED**  
트랜잭션 없이 동작하도록 만들 수도 있다. 진행중인 트랜잭션이 있어도 무시한다.  
    * 트랜잭션을 무시하는 속성을 두는 이유 : 특별한 메소드만 트랜잭션 적용에서 제외하려고  

**격리수준**  
서버환경에서는 여러 개의 트랜잭션이 동시에 진행될 수 있다. 서로 독립적인 것이 좋겠지만, 그러면 성능이 크게 떨어질 수밖에 없기 때문에 적절하게 격리 수준을 조정해 가능한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않도록 제어가 필요하다.  

**제한시간**  
트랜잭션을 수행하는 제한시간 timeout을 설정할 수 있다.  
PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW와 함께 사용해야 의미가 있다.  

**읽기전용**  
읽기 전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막을 수 있고 데이터 액세스 기술에 따라 성능이 향상될 수도 있다.  
TransactionDefinition 타입 오브젝트를 사용하면 네 가지 속성을 이용해 트랜잭션 동작방식을 제어할 수 있다.   
트랜잭션 정의를 바꾸고 싶다면 디폴트 속성을 갖고 있는 DefaultTransactionDefinition을 사용하는 대신 외부에서 정의된 TransactionDefinition 오브젝트를 DI 받아서 사용하도록 만들면 된다.  
TransactionDefinition 타입의 빈을 정의해두면 프로퍼티를 통해 원하는 속성을 지정해줄 수 있다.  

#### 6.6.2 트랜잭션 인터셉터와 트랜잭션 속성  
**TransctionInterceptor**  
TransctionInterceptor 어드바이스의 동작방식은 TransctionAdvice와 같고, 트랜잭션 정의를 메소드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 추가로 제공한다.  
TransctionInterceptor는 PlatformTransactionManager와 Properties 타입의 두 가지 프로퍼티를 갖고 있다.  
두 번째 프로퍼티는 transactionAttributes로, 트랜잭션 속성을 정의한 프로퍼티이다.  

**메소드 이름 패턴을 이용한 트랜잭션 속성 지정**  
Properties 타입의 transactionAttributes 프로퍼티는 메소드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션이다. 
```
PROPAGATION_NAME, ISOLATION_NAME, readOnly, timeout_NNNN, -Exception1, +Exception2  

(트랜잭션 전파 방식, 격리 수준, 읽기전용 항목, 제한시간, 체크 예외 중 롤백으로 추가할 것, 런타임 예외지만 롤백시키지 않을 예외)
```
트랜잭션 전파 항목만 필수이고 나머지는 다 생략 가능.  

TransactionInterceptor 타입 빈의 예
```xml
<bean id="transactionAdvice" class="org.springframework.transaction.interceptor.Transactionlnterceptor">
    <property name="transactionManager" ref="transactionManager" /> <property name="transactionAttributes">
        <props>
            <prop key="get*">PROPAGATION_REQUIRED,readOnly,timeout_30</prop> 
            <prop key="upgrade*">PROPAGATION_REQUIRES_NEW,ISOLATION_SERIALIZABLE </prop>
            <prop key="*">PROPAGATION_REQUIRED</prop>
        </props> 
    </property>
</bean>
```
1. 이름이 get으로 시작하는 모든 메소드에 대한 속성
    (읽기 전용이 아닌 트랜잭션 속성을 가진 메소드에서 읽기 전용 속성을 가진 메소드를 호출하면, PROPAGATION_REQUIRED이기 때문에 다른 트랜잭션이 시작되어 있으면 그 트랜잭션에 참여한다.)  
2. upgrade로 시작하는 메소드는 항상 독립적인 트랜잭션으로 동작한다(PROPAGATION_REQUIRES_NEW).  
3. *만 사용해서 위의 두 가지 조건에 해당하지 않는 나머지 모든 메소드에 사용될 속성 지정  

**tx 네임스페이스를 이용한 설정 방법**  
TransactionInterceptor 타입의 어드바이스 빈과 TransactionAttribute 타입의 속성 정보도 tx 스키마의 전용 태그를 이용해 정의할 수 있다.  
Transactionlnterceptor 빈으로 정의한 트랜잭션 어드바이스와 메소드 패턴에 따른 트랜잭션 속성 지정은 tx 스키마의 태그를 이용해 정의할 수 있다.  
```xml
...
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
...
```

#### 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략  
트랜잭션 부가기능을 적용할 후보 메소드를 선정하는 작업은 포인트컷에 의해 진행된다.  
어드바이스의 트랜잭션 전파 속성에 따라 메소드별로 트랜잭션의 적용 방식이 결정된다.  

**트랜재션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다**  
일반적으로 트랜잭션을 적용할 타깃 클래스의 메소드는 모두 트랜잭션 적용 후보가 되는 것이 바람직하다.  
쓰기 작업이 없는 단순한 조회 작업만 하는 메소드에도 모두 트랜잭션을 적용하는 게 좋다. 조회의 경우 읽기 전용으로 트랜잭션 속성을 설정해두면 성능 향상을 가져올 수 있다. 또한 복잡한 조회의 경우는 제한시간을 지정해줄 수도 있고, 격리 수준에 따라 조회도 트랜잭션 안에서 진행해야 할 필요가 발생하기도 한다.  

따라서 트랜잭션용 포인트컷 표현식에는 메소드나 파라미터, 예외에 대한 패턴을 정의하지 않는 것이 바람직하다. 트랜잭션의 경계로 삼을 클래스들이 선정됐다면, 그 클래스들이 모여 있는 패키지를 통째로 선택하거나 클래스 이름에서 일정한 패턴을 찾아서 표현식으로 만들면 된다.  

**공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.**  
가장 간단한 트랜잭션 속성 부여 방법은 모든 메소드에 대해 디폴트 속성을 지정하는 것이다.  
디폴트 속성을 일괄적으로 부여하고나서는 간단한 메소드 이름의 패턴을 적용해본다.  

트랜잭션 적용 대상 클래스의 메소드는 일정한 명명 규칙을 따르게 해야 한다.  
일반화하기 적당하지 않은 특별한 트랜잭션 속성이 필요한 타깃 오브젝트에 대해서는 별도의 어드바이스와 포인트컿ㅅ 표현식을 사용하는 편이 좋다.  

**프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.**  
프록시 방식의 AOP에서는 프록시를 통한 부가 기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능하다.  
반대로 타깃 오브젝트가 자기 자신의 메소드를 호출할 때는 프록시를 통한 부가기능의 적용이 일어나지 않는다.  
같은 타깃 오브젝트 안에서 메소드 호출이 일어나는 경우에는 프록시 AOP를 통해 부여해준 부가기능이 적용되지 않는다는 점을 주의해야 한다.  
따라서 같은 오브젝트 안에서의 호출은 새로운 트랜잭션 속성을 부여하지 못한다.  

#### 6.6.4 트랜잭션 속성 적용
**트랜잭션 경계설정의 일원화**  
트랜잭션 경계설정의 부가기능은 일반적으로 특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직하다. 비즈니스 로직을 담고 있는 서비스 계층 오브젝트의 메소드가 트랜잭션 경계를 부여하기 가장 적절한 대상이다.  
트랜잭션은 보통 서비스 계층의 메소드 조합을 통해 만들어지기 때문에 DAO가 제공하는 주요 기능은 서비스 계층에 위임 메소드를 만들어둘 필요가 있다. 가능하면 다른 모듈의 DAO에 접근할 때는 서비스 계층을 거치도록 하는 게 바람직하다.  

* ex)
userDao를 사용해야 하는 모든 메소드를 UserService에 등록해놓고, User 관련 데이터 조작은 UserService라는 트랜잭션 경계를 통해 진행하게 하면 모두 트랜잭션을 적용할 수 있다. 

**서비스 빈에 적용되는 포인트컷 표현식 등록**
upgradeLevels()에만 적용되게 했던 기존 포인트컷 표현식을 모든 비즈니스 로직의 서비스 빈에 적용되도록 수정한다.  

**트랜잭션 속성을 가진 트랜잭션 어드바이스 등록**  
- TransactionAdvice 클래스로 정의했던 어드바이스 빈을 스프링의 Transactionlnterceptor를 이용하도록 변경한다.  
- 메소드 패턴과 트랜잭션 속성은 가장 보편적인 방법인 get으로 시작하는 메소드는 읽기 전용으로, 나머지는 디폴트 트랜잭션 속성을 따르도록 설정한다.  
- tx 스키마에 정의된 태그를 이용하도록 tx 네임스페이스와 스키마를 추가하고 트랜잭션 어드바이스와 속성을 정의한다.  

**트랜잭션 속성 테스트**  
예외적인 상황을 만들어야 하기 때문에 트랜잭션 롤백 테스트를 위해 만든 TestUserrService를 활용한다.  
새로 추가한 getAll() 메소드를 오버라이드해서 강제로 DB에 쓰기 작업을 추가하면, 읽기 전용 트랜잭션 속성이 적용되어야 하기 때문에 쓰기 시도를 하면 그에 따른 예외가 발생할 것이다.  

정확히 어떤 예외가 발생할지 잘 모르므로 expected 조건을 주지 않고 테스트를 수행해서 예외 때문에 테스트가 실패하는 것을 확인하고 어떤 예외가 던져졌느지 확인해서 이를 다시 테스트 조건에 넣어준다.  


### 6.7 애노테이션 트랜잭션 속성과 포인트컷
---
#### 6.7.1 트랜잭션 애노테이션  
**@Transactional**  
@Transactional 어노테이션의 타깃은 메소드와 타입니다. 따라서 메소드, 클래스, 인터페이스에 사용할 수 있다. @Transactional을 트랜잭션 속성 정보로 사용하도록 지정하면 @Transactional이 부여된 모든 오브젝트를 자동으로 타깃 오브젝트로 인식한다.  
@Transactional은 기본적으로 트랜잭션 속성을 정의하는 것이지만, 동시에 포인트컷의 자동등록에도 사용된다.  

**트랜잭션 속성을 이용하는 포인트컷**  
@Transactional을 사용했을 때 어드바이저의 동작방식을 살펴보면,  TransactionInterceptor는 메소드 이름 패턴을 통해 부여되는 일괄적인 트랜잭션 속성정보 대신, @Transactional 어노테이션의 엘리먼트에서 트랜잭션 속성을 가져오는 AnnotationTransactionAttributeSource를 사용한다.  
@Transactional은 메소드마다 다르게 설정할 수도 있으므로 유연한 트랜잭션 속성 설정이 가능해진다.  
동시에 포인트 컷도 @Transactional을 통한 트랜잭션 속성정보를 참조하도록 만든다.  

이 방식을 이용하면 포인트컷과 트랜잭션 속성을 어노테이션 하나로 지정할 수 있다.  
트랜잭션 속성은 메소드 단위로 세분화해 다르게 지정할 수도 있기 때문에 세밀한 트랜잭션 속성 제어가 가능해진다.  

**대체 정책**  
스프링은 @Transactional을 적용할 때 4단계의 대체 정책을 이용하게 해준다.  
메소드의 속성을 확인할 때 타깃 메소드, 타깃 클래스, 선언 메소드, 선언 타입 순서에 따라 @Transactional이 적용됐는지 차례로 확인하고, 가장 먼저 발견되는 속성정보를 사용하게 한다.  
@Transactional을 사용하면 대체 정책을 잘 활용해서 어노테이션 자체는 최소한으로 사용하면서도 세밀한 제어가 가능하다. @Transactional은 먼저 타입 레벨에 정의되고, 공통 속성을 따르지 않는 메소드에 대해서만 메소드 레벨에 다시 @Transactional을 부여해주는 식으로 사용해야 한다.  
@Transactional은 인터페이스보다는 타깃 클래스와 타깃 메소드에 적용하는 편이 낫다.  
인터페이스를 사용하는 프록시 방식의 AOP가 아닌 방식으로 트랜잭션을 적용하면 인터페이스에 정의한 @Transactional은 무시되기 때문이다.  
인터페이스에 두면 구현 클래스가 바뀌더라도 트랜잭션 속성을 유지할 수 있다는 장점이 있다.  

**트랜잭션 애노테이션 사용을 위한 설정**  
@Transactional을 이용하기 위해 필요한 설정
```
<tx:annotation-driven />
```

#### 6.7.2 트랜잭션 애노테이션 적용
인터페이스 방식의 프록시를 사용하는 경우에는 인터페이스 @Transactional을 적용해도 상관없다.   


### 6.8 트랜잭션 지원 테스트
---
#### 6.8.1 선언적 트랜잭션과 트랜잭션 전파 속성  
트랜잭션을 정의할 때 예를 들어 REQUIRED로 전파 속성을 지정해줄 경우, 앞에서 진행 중인 트랜잭션이 있으면 참여하고 없으면 자동으로 새로운 트랜잭션을 시작해준다. REQUIRED 전파 속성을 가진 메소드를 결합해서 다양한 크기의 트랜잭션 작업을 만들 수 있다. 트랜잭션 적용 때문에 불필요하게 코드를 중복하는 것도 피할 수 있으며, 어플리케이션을 작은 기능 단위로 쪼개서 개발할 수 있다.  
@REQUIRED 방식의 트랜잭션 전파 속성이 지정된 메소드는 스스로 트랜잭션 경계를 설정할 수 있지만, 때로는 다른 메소드에서 만들어진 트랜잭션의 경계 안에 포함된다.  

![image](https://user-images.githubusercontent.com/44107947/58558242-41422700-825b-11e9-8fd6-6bcdfe625a0c.png)


* **선언적 트랜잭션**  
: AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정할 수 있게 하는 방법
* **프로그램에 의한 트랜잭션**  
: TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법  

#### 6.8.2 트랜잭션 동기화와 테스트
**트랜잭션 매니저와 트랜잭션 동기화**  
- 트랜잭션 추상화 기술의 핵심은 트랜잭션 매니저와 트랜잭션 동기화.   
- 트랜잭션 매니저  
    : PlatformTransactionManager 인터페이스를 구현한 트랜잭션 매니저를 통해 구체적인 트랜잭션 기술의 종류에 상관없이 일관된 트랜잭션 제어 가능
- 트랜잭션 동기화
    - 시작된 트랜잭션 정보를 저장소에 보관해뒀다가 DAO에서 공유 가능  
    - 트랜잭션 전파에 있어서도 중요한 역할  

- 테스트 상황
    ```java
    @Test
    public void transactionSync() {
        userService.deleteAll();
        userService.add(users.get(0)); 
        userService.add(users.get(1));
    }
    ```
    - 위 메소드가 실행되는 동안 3개의 트랜잭션이 만들어진다. 
    - 각 메소드가 모두 독립적인 트랜잭션 안에서 실행된다.
      (테스트에서 각 메소드를 실행시킬 때는 기존에 진행 중인 트랜잭션이 없고 트랜잭션 전파 속성은 REQUIRED이므로 새로운 트랜잭션이 시작된다.)
    - 메소드가 정상적으로 종료하는 순간 트랜잭션은 커밋되면서 종료된다. 

**트랜잭션 매니적를 이용한 테스트용 트랜잭션 제어**  
세 개의 트랜잭션을 하나로 통합할 수 있는 방법
    - 세 개의 메소드 모두 트랜잭션 전파 속성이 REQUIRED이므로 이 메소드들이 호출되기 전에 트랜잭션이 시작되게 하면 가능하다. 

트랜잭션의 전파는 트랜잭션 매니저를 통해 트랜잭션 동기화 방식이 적용되기 때문에 가능하므로 테스트에서 트랜잭션 매니저를 이용해 트랜잭션을 시작시키고 이를 동기화해주면 된다.   

트랜잭션을 시갖하기 위해서는 먼저 트랜잭션 정의를 담은 오브젝트를 만들고 이를 트랜잭션 매니저에 제공하면서 새로운 트랜잭션을 요청하면 된다.  

**트랜잭션 동기화 검증**  
트랜잭션 속성 중 읽기전용과 제한시간 등은 처음 트랜잭션이 시작할 때만 적용되고 그 이후에 참여하는 메소드 속성은 무시된다.  
스프링의 트랜잭션 추상화가 제공하는 트랜잭션 동기화 기술과 트랜잭션 전파 속성 덕분에 테스트도 트랜잭션으로 묶을 수 있다.  
이런 방법은 선언적 트랜잭션이 적용된 서비스 메소드에만 적용되는 것이 아니라 JdbcTemplate과 같이 스프링이 제공하는 데이터 액세스 추상화를 적용한 DAO에도 동일한 영향을 미친다.  

**롤백 테스트**  
롤백 테스트는 테스트 내의 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게 하고, 테스트가 끝나면 무조건 롤백해버리는 테스트이다.  
롤백 테스트는 DB 작업이 포함된 테스트가 수행돼도 DB에 영향을 주지 않기 때문에 장점이 많다.  
- 테스트에서 DB에 쓰기 작업을 하는 기능을 실행하면서 테스트를 수행하고 나면 DB의 데이터가 바뀜  
- DB를 액세스하는 테스트를 위해서는 테스트를 할 때마다 테스트 데이터를 초기화하는 번거로운 작업 필요 
- 테스트를 위해 미리 준비해둘 수 있는 공통 테스트 데이터가 있는데, DB 데이터를 수정하고 삭제하는 등의 작업을 진행하는 테스트 때문에 준비한 테스트 데이터를 사용할 수 없다.  

롤백 테스트는 테스트를 진행하는 동안에 조작한 데이터를 모두 롤백하고 테스트를 시작하기 전 상태로 만들어준다.  
어떤 경우에도 트랜잭션을 커밋하지 않기 때문에 테스트가 성공하든 실패하든 상관없이 처음과 동일한 테이브르이 테스트 데이터로 테스트를 수행할 수 있다.  


#### 6.8.3 테스트를 위한 트랜잭션 애노테이션  
**@Transactional**  
테스트 클래스 또는 메소드에 @Transactional 어노테이션을 부여해주면 타깃 클래스나 인터페이스에 적용된 것처럼 테스트 메소드에 트랜잭션 경계가 자동으로 설정된다.  
이를 이용하면 테스트 내에서 진행하는 모든 트랜잭션 관련 작업을 하나로 묶어줄 수 있다.  

테스트에서 사용하는 @Transactional은 AOP를 위한 것은 아니다.  
컨텍스트 테스트 프레임워크에 의해 트랜잭션을 부여해주는 용도로 쓰일 뿐이다.  

**@Rollback**  
테스트에 적용된 @Transactional은 기본적으로 트랜잭션을 강제 롤백시키도록 설정되어 있다.  
하지만 테스트 메소드 안에서 진행되는 작업을 하나의 트랜잭션으로 묶고 싶기는 하지만 강제 롤백을 원하지 않을 경우에는 @Rollback 어노테이션을 이용하면 된다.  
```java
@Test
@Transactional
@Rollback(false)
public void transactionSync(){ ... }
```

**@TransactionConfiguration**  
@Transactional은 테스트 클래스에 넣어서 모든 테스트 메소드에 일괄 적용할 수 있지만 @Rollback은 메소드 레벨에만 적용할 수 있다.  
따라서 테스트 클래스의 모든 메소드에 트랜잭션을 적용하면서 커밋되게 하려면 @TransactionConfiguration 어노테이션을 이용하면 된다.  
@TransactionConfiguration을 사용하면 롤백에 대한 공통 속성을 지정할 수 있다. 디폴트 롤백 속성은 false로 해두고, 롤백을 적용하고 싶은 일부에만 @Rollback을 부여해주면 된다.  

**NotTransactional과 Propagation.NEVER**  
테스트 클래스에 @Transactional을 지정했을 경우 굳이 트랜잭션이 필요 없는 메소드에는 @NotTransactional을 부여하면 된다.  
혹은 @NotTransactional 대신 @Transactional의 트랜잭션 전파 속성 중 NEVER를 사용하는 방법도 있다. 

**효과적인 DB 테스트**  
단위테스트와 통합테스트는 아예 클래스를 구분해서 따로 만드는 게 좋다.  
DB가 사용되는 통합 테스트를 별도의 클래스로 만들어둔다면 기본적으로 클래스 레벨에 @Transactional을 부여해준다. DB가 사용되는 통합 테스트는 가능한 롤백 테스트로 만드는 게 좋다.  