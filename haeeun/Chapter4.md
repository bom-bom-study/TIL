## 4장 예외
### 4.1 사라진 SQLException
---
#### 4.1.1 초난감 예외처리
##### 예외 블랙홀  
발생한 예외를 catch블록으로 잡아낸 후 아무것도 하지 않는 경우, 발생한 예외로 인해 어떤 기능이 비정상적으로 동작하거나, 메모리나 리소스가 소진되거나, 예상치 못한 다른 문제를 일으킬 수 있다. 최종적으로 오작동을 하거나 시스템 오류가 나고, 오류의 원인이 무엇인지 찾아내기 매우 힘들다.  
예외 처리 시 반드시 지켜야 할 핵심 원칙은 **모든 예외는 적절하게 복구 되거나 작업을 중단시키고 통보 되어야 한다**는 것이다. 예외를 잡아서 조치를 취할 방법이 없다면 잡지 말고, 메소드에 throws Exception을 선언해서 메소드 밖으로 던지고 자신을 호출한 코드에 예외처리 책임을 전가해야 한다. 

##### 무의미하고 무책임한 throws  
사용하려고 하는 메소드에 throws Exception이 선언되어 있는 경우, 메소드 선언에서는 의미 있는 정보를 얻을 수 없다. 실행 중에 예외적인 상황이 발생할 수 있다는 것인지 불확실하다. 결과적으로 적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 없게 된다.

#### 4.1.2 예외의 종류와 특징
자바에서 throw를 통해 발생시킬 수 있는 예외  
##### Error    
java.lang.Error 클래스의 서브클래스들.  
에러는 시스템에 비정상적인 상황이 발생했을 경우에 사용되기 때문에 주로 JVM에서 발생시키는 것이고 어플리케이션 코드에서 잡으려고 하면 안된다. 따라서 시스템 레벨에서 특별한 작업을 하는 것이 아니라면 특별히 신경쓰지 않아도 된다.

##### Exception과 체크 예외  
java.lang.Exception 클래스와 그 서브클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 어플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.  
Exception 클래스는 **체크 예외**와 **언체크 예외**로 구분된다.
    > - Checked Exception : Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상속하지 않은 것들
    > - Unchecked Exception : RuntimeException을 상속한 클래스.   

    RuntimeException은 Exception의 서브클래스이므로 Exception의 일종이긴 하지만 자바에서는 RuntimeExcpetion과 그 서브클래스는 특별하게 다룬다.
일반적으로 예외라고 하면 Exception 클래스의 서브클래스 중에서 RuntimeException을 상속하지 않은 것만을 말한다(Checked Exception). 체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다. 하지 않으면 컴파일 에러 발생

##### RuntimeException과 언체크/런타임 예외  
java.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외(런타임 에러)라고 불린다. 런타임 예외는 예상하지 못했던 예외 상황에서 발생하는 것이 아니기 때문에 굳이 catch나 throws를 사용하지 않아도 되고 명시적으로 잡거나 throws로 선언해도 된다. 런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것이다. 

#### 4.1.3 예외처리 방법
##### 예외 복구  
예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것.  
예외로 인해 기본 작업 흐름이 불가능하다면 다른 작업 흐름으로 유도해 주는 것. 이런 경우 예외 상황은 다시 정상으로 돌아오고 예외를 복구했다고 볼 수 있다.   
예외처리 코드를 강제하는 체크 예외들은 예외를 어떤 식으로든 복구할 가능성이 있는 경우에 사용한다. 

##### 예외처리 회피  
예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던지는 것. throws문으로 선언해서 예외가 발생하면 알아서 던져지게 하거나 catch로 예외를 잡은 후 로그를 남기고 다시 예외를 던짐  
예외처리를 회피하려면 반드시 다른 오브젝트나 메소드가 예외를 대신 처리할 수 있도록 던져줘야 한다.
예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다. 콜백/템플릿처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 분명한 확신이 있어야 한다.  

##### 예외 전환  
예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드 밖으로 던지는 것. 예외 회피와 달리 발생한 예외를 그대로 넘기는 것이 아니라 적절한 예외로 전환해서 던진다.  
보통 전환하는 예외에 원래 발생한 예외를 담아서 중첩 예외로 만드는 것이 좋다. 중첩 예외는 getCause()를 이용해 처음 발생한 예외가 무엇인지 확인할 수 있다.  
**목적**
    - 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우, 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해 사용.
    **ex)**  
    DAO에서 SQLException을 그대로 밖으로 던지면 왜 Exception이 발생했는지 쉽게 알 수 없다. 따라서 DAO에서 SQLException의 정보를 해석해 DuplicateUserIdException 같은 예외로 바꿔서 던져주는 것이 좋다. 의미가 분명한 예외가 던져지면 서비스 계층 오브젝트에서는 적절한 복구 작업을 시도할 수 있다.  
    보통 전환하는 예외에 원래 발생한 예외를 담아서 중첩 예외로 만드는 것이 좋다. 중첩 예외는 getCause()를 이용해 처음 발생한 예외가 무엇인지 확인할 수 있다.
    ``` java
    catch(SQLException e){
        ...
        throw DuplicateUserIdExcption().initCause(e);
    }
    ```


    - 예외를 처리하기 쉽고 단순하게 만들기 위해 **포장**하는 것. 주로 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용  
    **ex)**  
    대표적으로 EJBException. EJB 컴포넌트 코드에서 발생하는 대부분의 체크 예외는 비즈니스 로직으로 볼 때 의미있는 예외이거나 복구 가능한 예외가 아니므로 이런 경우 런타임 예외인 EJBException으로 포장해서 던지는 편이 낫다. 런타임 예외로 만들어서 전달하면 이를 시스템 Exception으로 인식하고 트랜잭션을 자동으로 롤백 해준다.   
    반대로 어플리케이션 로직 상에서 예외조건이 발견되거나 예외상황이 발생할 경우에는 어플리케이션 코드에서 의도적으로 던지는 예외이므로 체크 예외를 사용하는 것이 적절하다.

    대부분 서버환경에서는 어플리케이션 코드에서 처리하지 않고 전달된 예외들을 일괄적으로 다룰 수 있는 기능을 제공한다. 복구하지 못하 예외라면 어플리케이션 코드에서는 런타임 예외로 포장해서 던지고, 예외처리 서비스 등을 이용해 자세한 로그를 남기고 통보하고, 사용자에게는 메시지를 보여주는 식으로 처리하는 것이 바람직하다.


#### 4.1.4 예외처리 전략
##### 런타임 예외의 보편화    
    ```
    일반적으로 체크 예외는 일반적인 예외, 언체크 예외는 시스템 장애나 프로그램 상의 오류
    ```
    자바 엔터프라이즈 서버환경에서는 수많은 사용자가 동시에 요청을 보내고 각 요청이 독립적인 작업으로 취급된다. 하나의 요청을 처리하는 중에 예외가 발생하면 해당 작업만 중단시키면 된다. 독립형 어플리케이션과 달리 서버의 특정 계층에서 예외가 발생했을 때 작업을 일시 중지하고 사용자와 바로 커뮤니케이션하면서 예외상황을 복구할 수 있는 방법이 없기 때문에 어플리케이션 차원에서 예외상황을 미리 파악하고 예외가 발생하지 않도록 차단하는 것이 좋다. 또는 프로그램 오류나 외부 환경으로 인해 예외가 발생하는 경우라면 해당 요청의 작업을 취소하고 서버관리자나 개발자에게 통보해주는 편이 낫다.

##### add() 메소드의 예외처리  
    DublicatedUserIdException도 체크 예외로 두지 않아도 된다. 의미있는 예외는 add()를 바로 호출한 오브젝트 대신 더 앞단의 오브젝트에서 다룰 수도 있다. 어디에서든 에러를 잡아서 처리할 수 있다면 체크 예외 대신 런타임 예외로 만드는 것이 낫다.  
    필요하면 언제든 잡아서 처리할 수 있도록 별도의 예외로 정의하기는 하지만, 필요없다면 신경쓰지 않아도 되도록 RuntimeException을 상속한 런타임 예외로 만든다. 중첩 예외를 만들 수 있도록 생성자를 추가해 주어야 한다.
    ```java
    // 아이디 중복 시 사용하는 예외
    public class DuplicateUserIdException extends RuntimeException {
        public DuplicateUserIdException(Throwable cause) {
            super(cause);
        }
    }
    ```

##### 애플리케이션 예외  
    런타임 예외 중심의 전략은 낙관적인 예외 처리 기법이라고 할 수 있다. 일단 복구할 수 있는 예외는 없다고 가정하고 예외가 생겨도 런타임 예외이므로 시스템 레벨에서 알아서 처리해 줄 것이고, 꼭 필요한 경우는 런타임 예외라도 잡아서 복구하거나 대응해줄 수 있으니 문제 될 것이 없다는 태도를 기반으로 하고 있기 때문이다.  
    반면 시스템 또는 외부의 예외상황이 원인이 아니라 어플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 catch해서 무엇인가 조치를 취하도록 요구하는 예외들을 어플리케이션 예외라고 한다.  
    cf) 예외를 처리하는 메소드를 설계하는 방법
    - **정상적인 경우와 예외가 발생한 경우 각각 다른 종류의 리턴 값을 돌려준다**.(리턴 값을 일종의 결과 상태를 나타내는 정보로 활용)  
    이러한 경우 예외 상황에 대한 리턴 값을 명확하게 코드화하고 잘 관리해야 한다. 또한 결과 값을 확인하는 조건문이 자주 등장하게 되어 코드가 지저분해질 수 있다.
    - **정상적인 흐름을 따르는 코드는 그대로 두고, 잔고 부족과 같은 예외 상황에서는 비즈니스적인 의미를 띤 예외를 던지도록 만든다**.  
    정상적인 흐름을 따르지만 예외가 발생할 수 있는 코드를 try 블록 안에 정리해두고 예외상황에 대한 처리를 catch 블록에 모아 두면 된다. 이 때 사용하는 예외는 의도적으로 체크 예외로 만든다.

#### 4.1.5 SQLException은 어떻게 됐나?  
스프링의 JdbcTemplate은 템플릿과 콜백 안에서 발생하는 모든 SQLException을 런타임 예외인 DataAccessException으로 포장해서 던져준다. 따라서 JdbcTemplate을 사용하는 Dao 메소드에서는 꼭 필요한 경우에만 런타임 예외인 DataAccessException을 잡아서 처리하면 되고 그 외의 경우 무시해도 된다.  



### 4.2 예외 전환
---
#### 4.2.1 JDBC의 한계
JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해놓고, 각 DB 업체가 JDBC 표준을 따라 만들어진 드라이버를 제공하게 해준다. JDBC의 Connection, Statement, ResultSet 등의 표준 인터페이스를 통해 기능을 제공한다.  
하지만 DB 종류에 상관없이 사용할 수 있는 데이터 액세스 코드를 작성하는 일은 쉽지 않다. DB를 자유롭게 변경해서 사용할 수 있는 유연한 코드를 보장해주지는 못한다.  
1. 비표준 SQL  
SQL은 어느 정도 표준화된 언어이고 몇 가지 표준 규약이 있긴 하지만, 대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능도 제공한다. 비표준 SQL은 DAO 코드에 들어가고, 해당 DAO는 특정 DB에 종속적인 코드가 된다. 이러한 경우 DAO를 DB별로 만들어 사용하거나 SQL을 외부에서 독립시켜 바꿔 쓸 수 있게 하는 방법을 사용할 수 있다.  

2. 호환성 없는 SQLException의 DB 에러정보  
SQLException의 원인은 매우 다양하다. 문제는 DB마다 에러의 종류와 원인도 제각가이다. 그래서 JDBC는 데이터 처리 중에 발생하는 다양한 예외를 SQLException 하나에 모두 담아버린다. 또한 DB에 독립적인 에러 정보를 얻기 위해서 예외가 발생했을 때의 DB 상태를 담은 SQL 상태정보를 부가적으로 제공한다. 하지만 DB의 JDBC 드라이버에서 SQLException을 담을 상태 코드를 정확하게 만들어주지 않는다. 호환성 없는 에러 코드와 표준을 따르지 않는 상태코드를 가진 SQLException만으로 DB에 독립적인 유연한 코드를 작성하는 것은 거의 불가능하다.

#### 4.2.2 DB 에러 코드 매핑을 통한 전환
**SQLException의 비표준 에러코드와 SQL 상태 정보에 대한 해결책**  
DB별 에러 코드를 참고해서 발생한 예외의 원인이 무엇인지 해석해 주는 기능을 만든다.  
스프링은 DB별 에러코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은 에러 코드 매핑 정보 테이블을 만들어 두고 이를 이용한다.  
JdbcTemplate은 SQLException을 런타임 예외로 포장하는 것이 아니라 DB의 에러 코드를 DataAccessException 계층구조의 클래스 중 하나로 매핑해준다. 

#### 4.2.3 DAO 인터페이스와 DataAccessException 계층구조
DataAccessException은 JDBC의 SQLException을 전환하는 용도 뿐만 아니라 JDBC 외의 자바 데이터 액세스 기술(JDO, JPA 등)에서 발생하는 예외에도 적용된다. 또한 TopLink나 하이버네이트 같은 독자적인 프로그래밍 모델을 지원하는 ORM 기술도 있다.  
DataAccessException은 의미가 같은 예외라면 데이터 액세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어 준다. 즉, 데이터 액세스 기술에 독립적인 추상화된 예외를 제공한다.   

##### DAO 인터페이스와 구현의 분리  
DAO를 분리하는 이유는 데이터 액세스 로직을 담은 코드를 성격이 다른 코드에서 분리하기 위해서이다. 또한 분리된 DAO는 전략 패턴을 적용해 구현 방법을 변경해서 사용할 수 있게 만들기 위해서이기도 하다. DAO를 사용하는 쪽에서는 DAO가 내부에서 어떤 데이터 액세스 기술을 사용하는지 신경 쓰지 않아도 된다.  
하지만 DAO의 사용 기술과 구현 코드는 전략 패턴과 DI를 통해 DAO를 사용하는 클라이언트에게 감출 수 있지만, 메소드 선언에 나타나는 예외 정보가 문제가 될 수 있다.  
이는 인터페이스로 메소드의 구현은 추상화했지만 구현 기술마다 던지는 예외가 다르기 때문에 메소드의 선언이 달라진다는 문제가 발생한다.  
가장 단순한 해결 방법은 모든 예외를 다 받아주는 throws Exception으로 선언하는 것이다. 혹은 DAO에서 SQLException을 던지는 JDBC API를 직접 사용하는 방법이다. DAO 메소드 내에서 런타임 예외로 포장해서 던지면 된다.  
하지만 DAO의 사용 기술에 따라 예외 처리 방법이 달라져야 하기 때문에 DAO의 기술에 의존적이다. 


2. 데이터 액세스 예외 추상화와 DataAccessException 계층구조
DataAccessException 계층 구조 안에는 자바의 다양한 데이터 액세스 기술을 사용할 때 발생하는 예외들이 추상화 되어 있다. 일부 기술에서만 공통적으로 나타나는 예외를 포함해서 데이터 액세스 기술에서 발생 가능한 대부분의 예외를 계층 구조로 분류해 놓았다.  
ORM 처럼 오브젝트/엔티티 단위로 정보를 업데이트 하는 경우에는 *낙관적인 락킹*이 발생할 수 있다. 이는 같은 정보를 두 명 이상의 사용자가 동시에 조회하고 순차적으로 업데이트할 때, 뒤늦게 업데이트 한 것이 먼저 업데이트한 것을 덮어쓰지 않도록 막아주는 데 쓸 수 있는 기능이다.  
DataAccessException 계층구조에는 템플릿 메소드나 DAO 메소드에서 직접 활용할 수 있는 예외도 정의되어 있다.  
JdbcTemplate과 같이 스프링의 데이터 액세스 지원 기술을 이용해 DAO를 만들면 사용 기술에 독립적인 일관성 있는 예외를 던질 수 있다. 인터페이스 사용, 런타임 예외 전환과 함께 DataAccessException 예외 추상화를 적용하면 데이터 액세스 기술과 구현 방법에 독립적인 이상적인 DAO를 만들 수 있다.

#### 4.2.4 기술에 독립적인 UserDao 만들기
##### 인터페이스 적용  
DAO 클래스를 인터페이스와 구현을 분리

##### 테스트 보완  
@Autowired는 스프링의 컨텍스트 내에서 정의된 빈 중에서 인스턴스 변수에 주입 가능한 빈을 찾아 준다. UserDao는 UserDaoJdbc가 구현한 인터페이스이므로 UserDaoTest의 dao 변수에 UserDaoJdbc 클래스로 정의된 빈을 넣는데 문제가 없지만, DAO의 기능을 검증하는 것이 목적이므로 UserDao를 그대로 두고 스프링 빈을 인터페이스로 가져오도록 만드는 편이 낫다.   

##### DataAccessException 활용 시 주의사항  
DataAccessException이 기술에 상관없이 어느 정도 추상화 된 공통 예외로 변환해주긴 하지만 근본저인 한계 때문에 완벽하다고 볼 수는 없다. DataAccessException을 잡아서 처리하는 코드를 만들려고 한다면 미리 학습 테스트를 만들어서 실제로 전환되는 예외의 종류를 확인해 둘 필요가 있다.