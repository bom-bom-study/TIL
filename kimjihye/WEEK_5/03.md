### 서비스 추상화와 단일 책임 원칙

기술과 서비스에 대한 추상화 기법
같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리 => 같은 계층에서 수평적인 분리

트랜잭션추상화는 이와 좀 다르다
애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우레벨의 트랜잭션 기술이라는 아예 다른
계층의 특성을 갖는 코드를 분리한 것

애플리케이션 계층 ( 애플리케이션의 로직을 담고 있음 )
결합도가 낮다 ( 로직이나 기술이 바뀐다고 할지라도 코드에는 영향을 주지 않는다. 서로 독립적으로 확장이 가능하다. )

트랜잭션 기술과도 스프링이 제공하는 PlatformTransactionManager 인터페이스를 통한
추상화 계층을 사이에 두고 사용하게 했기 때문에,
구체적인 트랜잭션 기술에 독립적인 코드가 됐다.

애플리케이션 로직의 종류에 따른 수평적인 구분이든
로직과 기술이라는 수직적인 구분이든
모두 결합도가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는데는
스프링의 DI가 중요하다

DI의 가치는 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는 데 있다.

### 단일 책임 원칙
하나의 모듈은 한 가지 책임을 가져야 한다
하나의 모듈이 바뀌는 이유는 한가지여야 한다

장점 : 어떤 변경이 필요할 때 수정 대상이 명확해진다.

트랜잭션 동기화 기법 ?

적절하게 책임과 관심이 다른 코드를 분리하고,
서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고,
애플리케이션 로직과 기술/환경을 분리하는 등의 작업은
갈수록 복잡해지는 엔터프라이즈 어플리케이션에는 반드시 필요하다

이를 위한 핵심적인 도구가 스프링이 제공하는 DI다.
스프링의 DI가 없었다면 인터페이스를 도입해서 나름 추상화를 했더라도 적지 않은 코드 사이의
결합이 남아있게 됨.

객체지향 설계와 프로그래밍 원칙은 서로 긴밀하게 관련이 있다
단일 책임 원칙을 잘 지키는 코드를 만들려면
인터페이스를 도입하고 이를 DI로 연결해야 하며
그 결과로 단일 책임 원칙 뿐 아니라 개방 폐쇄 원칙도 잘 지키고
모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고
같은 이유로 변경이 단일 책임에 집중되는 응집도 높은 코드가 나온다...

이런 과정에서
전략패턴, 어댑터패턴, 브리지패턴, 미디에이터패턴 등 많은 디자인 패턴이 자연스레 적용된다.

객체지향 설계원칙을 잘 지켜서 만든 코드는 테스트 하기도 편하다
스프링이 지원하는 DI와 싱글톤 레지스트리 덕분에 편리하게 자동화된 테스트를 만들 수 있다

템플릿/콜백 패턴도 DI를 응용했다 (스프링컨테이너 대신 마이크로 DI방식을 사용하긴 했지만)


스프링 사용하는 장점!!
DI원리를 잘 활용해서 스프링을 열심히 사용하다 보면, 어느 날 자신이 만든 코드에
객체지향 원칙과 디자인 패턴의 장점이 잘 녹아 있다는 걸 알 수 있다.

-----

### 서비스 추상화와 단일 책임 원칙
스프링의 트랜잭션 서비스 추상화 기법을 이용해 다양한 트랜잭션 기술을 일관된 방식으로 제어할 수 있다.

설정을 고치는 것만으로도 DB 연결 기술, 데이터 액세스 기술, 트랜잭션 기술을 자유롭게 바꿔서 사용할 수 있다.
ㅎㅎ
#### 수직, 수평 계층구조와 의존관계
기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.

같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리
=> 같은 계층에서 수평적인 분리

트랜잭션의 추상화는 애플리케이션의 비즈니스 로직과 그 하위에 동작하는 로우레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 갖는 코드를 분리한 것이다.

애플리케이션 로직의 종류에 따른 수평적인 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는 데는 스프링의 DI가 중요한 역할을 하고 있다. DI의 가치는 이렇게 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는 데 있다.

단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI로 연결해야 하며, 그 결과로 단일 책임 원칙 뿐 아니라 개방폐쇄 원칙도 잘 지키고, 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응짐도 높은 코드가 나온다.

뿐만 아니라 전략 패턴, 어댑터 패턴, 브리지 패턴, 미디에이터 패턴등 많은 디자인 패턴이 자연스럽게 적용된다.

객체지향 설계원칙을 잘 지켜서 만든 코드는 테스트하기도 편하다.
스프링이 지원하는 DI와 싱글톤 레지스트리 덕분에 더욱 편리하게 자동화된 테스트를 만들 수 있다.
