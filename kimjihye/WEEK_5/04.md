# 테스트를 위한 서비스 추상화

실제 메일 전송을 수행하는 JavaMail대신에 테스트에서 사용할, JavaMail과 같은 인터페이스를 갖는 오브젝트를 만들어서 사용하면 문제는 모두 해결된다.



메일 서비스 추상화

UserService의 upgradeLevel()메서드에 메일 발송 기능 추가

User생성자가 email을 받을 수 있게 하고, 테스트 데이터를 맞게 준비한 뒤 등록과 수정, 조회

과연 테스트를 하면서 매번 메일이 발송되는 것이 바람직한가 ?

- 테스트 때는 메일 서버 설정을 다르게 해서 테스트용으로 따로 준비된 메일 서버를 이용하자
  - 테스트 메일 섭는 외부로 메일을 발송하지 않고, 단지 JavaMail과 연동해서 메일 전송 요청을 받는 것까지만 담당한다.

SMTP라는 표준 메일 발송 프로토콜로 메일 서버에 요청이 전달되기만 하면 메일이 발송될거라 믿고 테스트를 수행하자
JavaMail API를 통해 요청이 들어간다는 보장만 있다면 굳이 테스트할 때마다 JavaMail을 직접 구동시킬 필요 없다.

테스트를 위한 추상화
```
Session s = Session.getInstance(props, null);
```

이 Session은 인터페이스가 아니라 클래스다. 생성자가 모두 private으로 되어 있어 직접 생성도 불가능.
static factory 메서드를 이용해 오브젝트를 만드는 방법 뿐이다.
게다가 Session 클래스는 더 이상 상속이 불가능한 final 클래스임

즉, JavaMail의 구현을 테스트용으로 바꾸는 것은 불가능하다
JavaMail은 확장이나 지원이 불가능하도록 만들어진 가장 악명높은 표준 API


서비스 추상화를 적용하면 된다.

뿐만아니라 스프링은 JavaMail에 대한 추상화 기능을 제공하고 있다

```
public interface MailSender {
    void send(SimpleMailMessage simpleMessage) throws MailException;
    void send(SimpleMailMessage[] simpleMessages) throws MailException;
}
```

메일 발송 기능을 제공하는 JavaMailSenderIml


스프링 빈으로 등록되는 MailSender의 구현 클래스들은 싱글톤으로 사용 가능해야 한다

JavaMail을 사용하지 않고, 메일 발송 기능이 포함된 코드를 테스트하기 위해
메일 전송 기능을 추상화해서 인터페이스를 적용하고 DI를 통해 빈으로 분리했다.

아무런 기능이 없는 빈 MainSender 구현 클래스다
```
public class DummyMailSender implements MailSender {
    public void send(SimpleMailMessage mailMessage) throws MailException {
    }

    public void send(SimpleMailMessage[] mailMessage) throws MailException {
    }
}
```

일반적으로 서비스 추상화라고 하면 트랜잭션과 같이 기능은 유사하나
사용 방법이 다른 로우레벨의 다양한 기술에 대해
추상 인터페이스와 일관성 있는 접근 방법을 제공해주는 것을 말한다.

MailSender 인터페이스를 구현한, 메일 발송 큐의 구현을 하나 만들어두고 다시 DI를  통해
JavaMailServiceImpl같은 실제 메일 발송용 오브젝트를 연결해서 사용할 수 있다

메일을 발송한다는 비즈니스 로직이 바뀌지 않는 한 UserService는 수정할 필요가 없다

트랜잭션 개념 적용 안되있음
해결 방법 두가지
1. 발송 대상을 별도의 목록에 저장 ( 단점 : 메일 저장용 리스트를 파라미터로 계속 갖고다녀야함)
2. MailSender를 확장해서 메일 전송에 트랜잭션 개념을 적용한다
  MailSender를 구현한 트랜잭션 기능이 있는 메일 전송용 클래스를 만든다



  서비스 추상화란 원활한 테스트만을 위해서도 충분히 가치가 있다
  기술이나 환경이 바뀔 가능성이 있음에도,
  JavaMail처럼 확장이 불가능하게 설계해놓은 API를 사용해야 하는 경우라면
  추상화 계층의 도입을 적극 고려해보자

  특별히 외부의 리소스와 연동하는 대부분의 작업은 추상화 대상이 될 수 있다.

  하나의 오브젝트가 사용하는 오브젝트를 DI에서 의존 오브젝트라고 부름
  의존한다는 말은 종속되거나 기능을 사용한다는 의미다

  => 작은 기능이라도 다른 오브젝트의 기능을 사용하면
  사용하는 오브젝트의 기능이 바뀌었을 때 자신이 영향을 받을 수 있기 때문에 의존하고 있다고 말하는 것이다
  의존 오브젝트 = 협력 오브젝트


테스트만을 위해서도 DI는 유용하다


### 테스트 대역의 종류와 특징
테스트용으로 사용되는 오브젝트 = 테스트 대상인 오브젝트의 의존 오브젝트들
= 테스트 대역 test double

대표적인 테스트 대역은 테스트 스텁
테스트 대상 오브젝트의 의존객체로 존재하면서 테스트 동안 코드가 정상적으로 수행할 수 있도록 돕는다

테스트 스텁은 메서드를 통해 전달하는 파라미터와 달리, 테스트 코드 내부에서 간접적으로 사용됨
따라서 DI등을 통해 미리 의존 오브젝트를 테스트 스텁으로 변경해야 한다.

테스트 스텁은 호출만 하면 그만인 것도 있지만, 결과를 돌려줘야 할 때도 있다.
=> 이 경우 스텁에 미리 테스트 중에 필요한 정보를 리턴해주도록 만들 수 있음
=> 강제로 예외를 발생시키게 해서 테스트 대상 오브젝트가 예외 상황에서 어떻게 반응할지 테스트할 때 적용할 수 있음

테스트 대역은 간접적인 도움뿐 아니라 테스트 과정에 매우 적극적으로 참여할 수 있음

단위테스트에서는 보통 입력 값을 테스트 대상 오브젝트의 메서드의 파라미터로 전달하고,
메서드의 리턴 값을 출력 값으로 보고 검증한다

스텁을 이용하면 간접적인 입력 값을 지정해줄 수 있다.

테스트 대상 오브젝트의 메서드가 돌려주는 결과뿐 아니라 테스트 오브젝트가
간접적으로 의존 오브젝트에 넘기는 값과 그 행위 자체에 대해서 검증하고 싶다면
assertThat()만으로는 검증이 불가능하다

테스트 대상의 간접적인 출력 결과를 검증하고, 테스트 대상 오브젝트와 의존 오브젝트 사이에서 일어나는 일을
검증할 수 있도록 특별히 설계된 Mock object를 사용해야 한다

Mock object는 스텁처럼 테스트 오브젝트가 정상적으로 실행되도록 도와주면서
테스트 오브젝트와 자신 사이에서 일어나는 커뮤니케이션 내용을 저장해뒀다가 테스트 결과를 검증하는데 활용할 수 있게 해준다.

테스트 대상 오브젝트는 테스트로부터 뿐 아니라 테스트 대상이 의존하고 있는 다른 의존 오브젝트와도
커뮤니케이션 한다.

테스트 대상 오브젝트가 의존 오브젝트에게 출력한 값에 관심이 있을 경우가 있음
의존 오브젝트를 얼마나 사용했는가 하는 커뮤니케이션 행위 자체에 관심이 있을 수 있음
이를 테스트에서는 직접 알 수 없다는 건데 이때 목 오브젝트를 만들어서 사용하면
테스트 대상과 의존 오브젝트 사이에 주고 받는 정보를 보존해둘 수 있다

JavaMail을 직접 사용하는 방식이라면
  - 메일발송 테스트는
    - 업그레이드 대상 주소에 넣은 메일 주소로 실제 메일이 들어왔는지 직접 확인하거나
    - 아주 복잡한 방법을 이용해 메일 서버의 로그를 뒤져서 메일 발송 로그가 그 시점에 남았는지 확인해야 함
JavaMail서비스 추상화를 적용해 목 오브젝트를 만들어서 사용하는 방식이므로
  - 아래와 같이 구현이 가능함
  ```java
  static class MockMailSender implements MailSender {
      private List<String> requests = new ArrayList<String>();

      public List<String> getRequests() {
          return requests;
      }

      public void send(SimpleMailMessage mailMessage) throws MailException {
          requests.add(mailMessage.getTo()[0]);
      }
  }
  ```

목 오브젝트를 이용한 테스트라는게,
작성하기는 간단하면서도 기능은 상당히 막강하다
보통의 테스트 방법으로는 검증하기가 매우 까다로운 테슽 대상 오브젝트의 내부에서 일어나는 일이나
다른 오브젝트 사이에서 주고받는 정보까지 검증하는 일이 손쉽다
