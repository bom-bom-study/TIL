# 서비스 추상화

### 5.3 서비스 추상화와 단일 책임 원칙
스프링의 트랜잭션 서비스 추상화 기법을 통해 설정을 고치는 것만으로도 DB 연결 기술, 데이터 액세스 기술, 트랜잭션 기술을 자유롭게 바꿔서 사용할 수 있게 됐다.

### 수직, 수평 계층구조와 의존관계
Dao와 Service는 각각 담당하는 코드의 기능적인 관심사에 따라 분리되고, 서로 영향을 주지 않으며 독자적으로 확장이 가능하도록 만들었다. 같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리했기 때문에, 수평적인 분리라고 부를 수 있다.

트랜잭션 추상화는 비즈니스 로직 하위에서 동작하는 로우레벨에서 아예 다른 계층의 특성을 갖는 코드를 분리한 것이다.

애플리케이션의 로직의 종류에 따른 수평적인 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는 데는 스프링의 DI가 중요한 역할을 하고 있다.

### 단일 책임 원칙
UserService는 사용자 관리 로직이 바뀌거나 추가되지 않는 한 코드에 손댈 이유가 없어야 한다. 서버환경이 바뀌고, Dao의 데이터를 가져오는 테이블이 바뀌고, Dao의 구현기술이 바뀌더라도 단 할 줄 수정할 필요가 없게 하는게 단일 책임 원칙을 충실하게 지키고 있는 것이다.

### 단일 책임 원칙의 장점
단일 책임 원칙을 지키는 코드가 됐을 때의 장점
* 어떤 변경이 필요할 때 수정 대상이 명확해진다.
    * 기술이 바뀌면 기술계층과의 연동을 담당하는 추상화 계층의 설정만 바꿔주면 된다.
    * 데이터를 가져오는 테이블 이름이 바뀌었다면 Dao를 변경하면 된다.

객체지향 설계와 프로그래밍 원칙은 서로 긴밀하게 관련이 있다. 단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI로 연결해야 하며, 그 결과로 단일 책임 원칙뿐 아니라 개방 폐쇄 원칙도 잘 지키고, 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도 높은 코드가 나오기 때문이다.

이런 과정에서 여러 디자인 패턴이 자연스럽게 적용되고 객체지향 설계 원칙을 잘 지켜서 만든 코드는 테스트하기도 편하다.

좋은 코드를 설계하고 만들려면 꾸준한 노력이 필요하다. 그저 기능이 동작한다고 해서 코드에 쉽게 만족하지 말고 계속 다듬고 개선하려는 자세도 필요하다.

지금까지 코드를 개선하고 발전시켜오면서 DI가 빠진 적이 없었다. 이렇게 스프링의 의존관계 주입 기술인 DI는 모든 스프링 기술의 기반이 되는 핵심 엔진이자 원리이며, 스프링이 지지하고 지원하는, 좋은 설계와 코드를 만드는 모든 과정에서 사용되는 가장 중요한 도구다.

### 5.4 메일 서비스 추상화
레벨이 업그레이드되는 사용자에게 안내 메일을 발송하기 위해 할 일 두가지
* User에 email 필드 추가
* UserService의 upgradeLevel() 메소드에 메일 발송 기능 추가

### JavaMail을 이용한 메일 발송 기능
DB의 User테이블에 email 필드 추가, User 클래스에 email 프로퍼티 추가 후 테스트 코드 수정 및 결과 확인

### JavaMail 메일 발송
자바에서 메일을 발송할 때는 표준 기술인 JavaMail울 사용하면 된다. javax.mail 패키지에서 제공하는 자바의 이메일 클래스를 사용한다.

JavaMail을 이용해 메일을 발송하는 기능이 추가하고 SMTP 프로토콜을 지원하는 메일 전송 서버가 준비되어 있다면 정상적으로 동작을 할 것이다.

### JavaMail이 포함된 코드의 테스트
운영 서버가 아니라 개발 중에 메일 서버가 준비되어 있지 않다면 테스트가 실패할 것이다.

그런데, 테스트를 하면서 매번 메일이 발송되는 것은 바람직하지 못하다. 메일 발송이란 매우 부하가 큰 작업이기 때문에 운영 중인 메일 서버를 통해 테스트를 실행하면 메일 서버에 상당한 부담을 줄 수 있다.

메일 서버 설정을 다르게 해서 테스트용으로 따로 준비된 메일 서버를 이용하는 방법은 분명히 나은 방법이지만, 업그레이드가 실제로 일어나는지, DB에 반영되는지 확인하는 것 만큼 중요하지는 않다. 그리고 SMTP는 충분히 테스트된 시스템이기 때문에 메일 전송 요청을 받으면 별 문제 없이 잘 전송됐다고 믿어도 충분하다.

개발 중이거나 테스트를 수행할 때는 JavaMail을 대신할 수 있는, 그러나 JavaMail을 사용할 때와 동일한 인터페이스를 갖는 코드가 동작하도록 만들어도 충분하다.

### 테스트를 위한 서비스 추상화
그런데 JavaMail의 핵심 API에는 DataSource처럼 인터페이스로 만들어져서 구현을 바꿀 수 있는게 없다.
* 메일 메시지를 생성해야할 Session 오브젝트가 인터페이스가 아니고 클래스다.
* 생성자가 모두 private로 되어 직접 생성도 불가능하다.
* Session 클래스는 더 이상 상속이 불가능한 final 클래스다.

JavaMail은 확장이나 지원이 불가능하도록 만들어진 가장 악명 높은 표준 API 중의 하나로 알려져 있다. JavaMail처럼 테스트하기 힘든 구조인 API를 테스트하기 좋게 만드는 방법이 트랜잭션을 적용하면서 살펴봤던 서비스 추상화를 적용하면 된다. 물론 스프링이 JavaMail에 대한 추상화 기능을 제공하고 있다.

### 메일 발송 기능 추상화
일반적으로 서비스 추상화라고 하면 트랜잭션과 같이 기능은 유사하나 사용 방법이 다른 로우레벨의 다양한 기술에 대해 추상 인터페이스와 일관성 있는 접근 방법을 제공해주는 것을 말한다. 반면에 JavaMail의 경우처럼 테스트를 어렵게 만드는 건전하지 않은 방식으로 설계된 API를 사용할 때도 유용하게 쓰일 수 있다.

특별히 외부의 리소스와 연동하는 대부분 작업은 추상화의 대상이 될 수 있다.

### 의존 오브젝트의 변경을 통한 테스트 방법
추상화 과정은 실제로 오브젝트를 교체하지 않더라도, 단지 테스트만을 위해서도 DI는 유용하다.

운영 중인 시스템에서 특정 DataSource 외에는 절대로 다른 것을 사용하지 않는다고 100% 확신하더라도, DAO에서 특정 DataSource 구현 클래스를 new로 직접 만들어서 사용하지 않는 편이 낫다. 운영 중에는 절대 바뀌지 않더라도 테스트 때는 바꿀 수밖에 없기 때문이다.

### 테스트 대역의 종류와 특징
테스트 대상인 오브젝트의 의존 오브젝트가 되는 특별한 오브젝트들이 있다. 
* UserDao의 DataSource
* UserService의 MailSender 인터페이스를 구현한 오브젝트

이렇게 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게, 자주 테스트를 실행할 수 있도록 사용하는 오브젝트를 통틀어서 테스트 대역(test double)이라고 부른다.
* 대표적인 테스트 대역은 테스트 스텁(test stub)
    * 테스트 대상 오브젝트의 의존객체로서 테스트 동안에 정상적으로 수행할 수 있도록 돕는 것
    * 메소드를 통해 전달하는 파라미터와 달리, 테스트 코드 내부에서 간접적으로 사용된다.
    * DI 등을 통해 미리 의존 오브젝트를 테스트 스텁으로 변경해야 한다.
    * DummyMailSender는 가장 단순하고 심플한 테스트 스텁의 예

테스트 대상 오브젝트의 메소드가 돌려주는 결과뿐 아니라 테스트 오브젝트가 간접적으로 의존 오브젝트에 넘기는 값과 그 행위 자체에 대해서도 검증하고 싶다면 목 오브젝트를 사용해야 한다.
* 목 오브젝트는 스텁처럼 테스트가 정상적으로 실행되도록 도와준다.
* 테스트 오브젝트와 자신의 사이에서 일어나는 커뮤니케이션을 저장해뒀다가 테스트 결과를 검증하는 데 활용할 수 있게 해준다.

> 테스트 대상의 간접적인 출력 결과를 검증하고, 테스트 대상 오브젝트와 의존 오브젝트 사이에서 일어나는 일을 검증할 수 있도록 특별히 설계된 오브젝트가 목 오브젝트이다.

### 목 오브젝트를 이용한 테스트
스텁 오브젝트
* 테스트가 수행될 수 있도록 의존 오브젝트에 간접적으로 입력 값을 제공해준다.

목 오브젝트
* 스텁 오브젝트의 기능과 간접적인 출력 값까지 확인하는 기능을 제공해준다.