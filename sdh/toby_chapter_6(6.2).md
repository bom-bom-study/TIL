# 스프링 AOP

### 6.2 고립된 단위 테스트
가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다.
* 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문이다.
* 반대로 테스트를 실행할 때 실행되는 코드의 양이 많다면 그 원인을 찾기가 매우 힘들다.
* 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워진다.

테스트 대상의 단위가 커지면 충분한 테스트를 만들기도 쉽지 않다. 어쩌면 코드를 살펴보는 것으로 충분하지 못해서, 디버거를 사용해 한 줄씩 실행해야 할 수도 있다.
* 처음부터 작은 단위로 테스트하면서 진행해왔다면, 나중에 덩치가 커져도 작은 단위로 테스트한 검증된 부분은 제외하고 접근할 수 있다.

하지만 작은 단위로 테스트하고 싶어도 그럴 수 없는 경우가 많다.
* 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.

### 복잡한 의존관계 속의 테스트
UserService의 구현 클래스들이 동작하려면 세 가지 타입의 의존 오브젝트가 필요하다.
* UserDao를 통해 DB와 데이터를 주고 받아야 한다.
* MailSender를 통해 메일을 발송해야 한다.
* PlatformTransactionManager와 커뮤니케이션이 필요하다.

UserService 테스트를 진행하는 동안 의존 오브젝트들도 같이 실행되기 때문에 사실은 그 뒤에 존재하는 훨씬 더 많은 오브젝트와 환경, 서비스, 서버 심지어 네트워크까지 함께 테스트하는 셈이 된다.
* UserService는 간단한 계산을 하는게 전부라면 배보다 배꼽이 더 큰 작업이 된다.

### 테스트 대상 오브젝트 고립시키기
테스트 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.

### 테스트를 위한 UserServiceImpl 고립
트랜잭션 코드를 독립시켜 PlatformTransactionManager에 더 이상 의존하지 않기 때문에 두 개의 목 오브젝트에만 의존하도록 만들 수 있다.

고립된 환경에서 동작하는 UserService 메소드의 테스트 결과를 검증할 방법이 없기 때문에 UserDao는 스텁이 아니라, 부가적인 검증 기능까지 가진 목 오브젝트로 만들어야 한다.
* UserDao와 같은 역할을 하면서 UserServiceImpl의 사이에서 주고받은 정보를 저장해놨다가, 테스트의 검증에 사용할 수 있게 만들 필요가 있다.

### UserDao 목 오브젝트
목 오브젝트는 기본적으로 스텁과 같은 방식으로 테스트 대상을 통해 사용될 때 필요한 기능을 지원해줘야 한다. 

먼저 upgradeLevels()메소드가 실행되는 중에 UserDao와 어떤 정보를 주고 받는지 입출력 내역을 확인할 필요가 있다.
* getAll()
    * DB에서 읽어온 것처럼 미리 준비된 사용자 목록을 제공해줘야 한다.(스텁)
* update(user)
    * 업그레이드를 통해 레벨이 변경된 사용자는 DB에 반영되도록 해야 한다.(목 오브젝트)

``` java
static class MockUserDao implements UserDao {
    private List<User> users; // 레벨 업그레이드 후보 User 목록
    private List<User> updated = new ArrayList(); // 업그레이드 대상 오브젝트를 저장해둘 목록

    private MockUserDao(List<User> users) {
        this.users = users;
    }

    public List<User> getUpdated() {
        return this.updated;
    }

    public List<User> getAll() {
        return this.users; // 스텁 기능 제공
    }

    public void update(User user) {
        updated.add(user); // 목 오브젝트 기능 제공
    }

    // ... 테스트에 사용되지 않는 메소드 UnsupportedDepreationException(); 처리
}
```

목 오브젝트를 사용하지 않을 때는 일일이 DB에 저장했다가 다시 가져와야 했지만, MockUserDao는 미리 준비된 테스트용 리스트를 메모리에 갖고 있다가 돌려주기만 하면 된다.

``` java
@Test
public void upgradeLevels() throws Exception {
    UserServiceImpl userServiceImpl = new UserServiceImpl(); // 고립된 테스트에서는 테스트 대상 오브젝트를 직접 생성하면 된다.

    MockUserDao mockUserDao = new MockUserDao(this.users);
    userServiceImpl.setUserDao(mockUserDao); // 목 오브젝트로 만든 UserDao를 직접 DI 해준다.

    // ... MockMailSender 세팅, upgradeLevels(); 실행

    List<User> updated = mockUserDao.getUpdated(); // 업데이트 결과를 가져온다.

    // 업데이트 잘 됬는지 확인
}
```

테스트 대역 오브젝트를 이용해 고립된 테스트로 만들기 전에는 @Autowired를 통해 가져온 UserService 타입의 빈이었다. 하지만 많은 의존 오브젝트, 서비스, 환경에 의존하고 있었다. 이제는 완전히 고립돼서 테스트만을 위해 독립적으로 동작하는 테스트 대상을 사용할 것이니 스프링 컨테이너에서 빈을 가져올 필요가 없다.

테스트를 고립된 상태로 하게된다면 스프링의 테스트 컨텍스트를 이용하기 위해 도입한 @RunWith 등은 제거할 수 있다.

### 테스트 수행 성능의 향상
테스트를 검증하는 데 직접적으로 필요하지 않은 의존 오브젝트와 서비스를 모두 제거해서 1밀리초도 되지 않는 짧은 시간에 나름 복잡한 비즈니스 로직을 가진 테스트를 실행시켰다.
* 고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없다.
* 테스트 수행 성능도 크게 향상된다.
* 부담 없이 자주 테스트를 돌려볼 수 있다.
* 모든 테스트가 고립 테스트라면 1000개의 테스트를 돌려도 1초도 안 걸릴 것이다.

고립된 테스트를 만들려면 목 오브젝트 작성과 같은 약간의 수고가 더 필요할지 모르겠지만, 그 보상은 충분히 기대할 만하다.

### 단위 테스트와 통합 테스트
단위 테스트의 단위는 정하기 나름이다. 중요한 것은 하나의 단위에 초점을 맞춘 테스트라는 점이다.
* 기능 전체
* 하나의 클래스
* 하나의 메소드

이 책에서는 다음과 같이 정의한다.
단위 테스트
* upgradeLevels() 테스트처럼 '테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 것
통합 테스트
* 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트
* 두 개 이상의 단위가 결합해서 동작하는 테스트
* 스프링 테스트 컨텍스트 프레임워크를 이용해서 컨텍스트에서 생성되고 DI된 오브젝트를 테스트하는 것도 통합 테스트

단위 테스트와 통합 테스트 중에서 어떤 방법을 쓸지 몇 가지 가이드라인이 있다.
* 항상 단위 테스트를 먼저 고려
* 하나의 클래스나 목적이 같은 클래스 몇개를 모아서 테스트 대역을 만든다.
* 단위 테스트는 테스트 작성도 간단하고 실행 속도도 빠르며 외부 환경에 영향을 받지도 않아서 빠른 시간에 효과적인 테스트를 작성하기에 유리하다.
* 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
* 단위 테스트로 만들기가 어려운 코드 중 대표적인 게 DAO다.
    * DAO는 그 자체로 로직을 담고 있기보다는 DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 한다.
    * SQL을 JDBC를 통해 실행하는 코드만으로는 고립된 테스트를 작성하기 힘들다.
    * DAO는 DB까지 연동하는 테스트로 만드는 편이 효과적이다.
    * DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고, DB에 직접 확인을 하는 등의 부가적인 작업이 필요하다.
* DAO 테스트는 DB라는 외부 리소스를 사용하기 때문에 통합 테스트로 분류된다. 하지만 코드에서만 보면 하나의 기능 단위를 테스트하는 것이기도 하다.
    * DAO를 충분히 검증해두면, DAO를 이용하는 코드는 스텁이나 목 오브젝트로 대체해서 테스트할 수 있다.
    * 물론 단위 테스트가 성공했더라도 여러 개의 단위를 연결하면 오류가 발생할 수도 있다.
* 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다.
    * 단위 테스트를 충분히 거쳤따면 통합 테스트의 부담은 상대적으로 줄어든다.
* 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해본다.
    * 이때도 통합 테스트에 참여하는 코드 중에서 가능한 한 많은 부분을 미리 단위 테스트로 검증해두는 게 유리하다.
* 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합테스트다.
    * 스프링의 지원 없이 코드 레벨의 DI를 사용하면서 단위 테스트를 하는 게 좋겠지만 스프링의 설정 자체도 테스트 대상이고, 스프링을 이용해 좀 더 추상적인 레벨에서 테스트해야 할 경우도 종종 있다.
    * 이럴 떈 스프링 컨텍스트를 이용해 통합 테스트를 작성한다.

코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관이다. 테스트하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될 가능성이 높다.

만약 DI도 사용하지 않고, 비즈니스 로직, 로우레벨 기술, 외부 환경과 성격이 다른 DAO가 한데 모여 강하게 경합되어 있는 코드라면, 쏟아지는 예외, 메시지, 알 수 없는 결과를 가지고 밤새 씨름해야 겨우 테스트가 가능할 것이다.

스프링이 지지하고 권장하는 깔끔하고 유연한 코드를 만들다 보면 테스트도 그만큼 만들기 쉬워지고, 품질을 높여주고, 리팩토링과 개선에 대한 용기를 주기도 한다.

### 목 프레임워크
단위 테스트를 만들기 위해서는 스텁이나 목 오브젝트의 사용이 필수적이다.

단위 테스트가 많은 장점이 있고 가장 우선시해야 할 테스트 방법인건 사실이지만 작성이 번거롭다는 점이 문제다.
* 번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 목 오브젝트 지원 프레임워크가 있다.

### Mockito 프레임워크
Mockito라는 프레임워크가 사용하기도 편리하고, 코드도 직관적이라 많은 인기를 끌고 있다.

Mockito와 같은 목 프레임워크의 특징
* 목 클래스를 일일이 준비해둘 필요가 없다.
* 간단한 메소드 호출만으로 다이내믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.

UserDao 인터페이스를 구현한 목 오브젝트는 다음과 같이 만들 수 있다.
UserDao mockUserDao = mock(UserDao.class);

아직 아무런 기능이 없고, 메소드가 불려올 때 원하는 데이터를 리턴하도록 스텁 기능을 추가해줘야 한다.
when(mockUserDao.getAll()).thenReturn(this.users);
이렇게 정의하면 getAll() 메소드가 호출되면 자동으로 users가 리턴될 것이다.

update() 호출이 있었는지 검증하는 부분이다. Mockito를 통해 만들어진 목 오브젝트는 메소드의 호출과 관련된 모든 내용을 자동으로 저장해두고, 이를 간단한 메소드로 검증할 수 있게 해준다.
verify(mockUserDao, times(2)).update(any(User.class));
테스트를 진행하는 동안 mockUserDao의 update() 메소드가 두 번 호출됐는지 확인하는 코드다.

Mockito 목 오브젝트는 다음의 네 단계를 거쳐서 사용하면 된다. 두 번째, 네 번째는 각각 필요할 경우에만 사용할 수 있다.
* 인터페이스를 이용해 목 오브젝트를 만든다.
* 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메소드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
* 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
* 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.
