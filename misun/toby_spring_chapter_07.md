# 토비의 스프링 3.1 Vol.1
## 7장 : 스프링 핵심 기술의 응용

### 7.1. SQL과 DAO의 분리
DB의 테이블이나 구조가 바뀌는 경우를 위하여

#### 7.1.1. XML 설정을 이용한 분리
- sql을 스프링의 xml 설정 파일로 뺀 후, 설정을 이용해 빈에 값을 주입해준다.
- DAO에서는 sql문을 외부로부터 주입받아 사용한다.
- 한계 : 매번 새로운 SQL이 필요할 때마다 프로퍼티를 추가하고, DI를 위한 변수와 수정자 메소드도 만들어줘야 한다.

##### SQL 맵 프로퍼티 방식
- SQL을 하나의 컬렉션으로 담아두는 방법 
- 맵을 이용하여 키값을 통해 SQL문장을 가져온다
- 그렇다면 프로퍼티는 하나도 만들어도 돼서 간결하다.
- Map은 여러개의 정보를 담고있기 때문에, <property value>가 아닌 <map> 태그를 사용
- 한계 : 메소드에서 SQL을 가져올 때 문자열로 된 키 값을 사용하기 때문에 오타가 있어도 메소드 실행 전에는 알 수 없다.

#### 7.1.2. SQL 제공 서비스
- xml설정을 이용한 방식의 문제점
    - sql 정보와 DI 설정 정보가 함께 있어 지저분하고 관리가 어렵다
    - 데이터 액세스 로직인 sql 문을 애플리케이션의 구성정보를 가진 설정정보와 두는 것은 바람직하지 못하다
=> 독립적인 SQL 제공 서비스가 필요!!!

##### SQL 서비스 인터페이스
- SQL 서비스 인터페이스를 설계한다
- DAO는 적절한 키를 제공해주고 그에대한 SQL을 돌려받기만 하면 된다
- 인터페이스 sqlService를 만들어, 인스턴스 변수인 sqlService를 통해 sql을 가져오도록 수정한다.

### 7.2. 인터페이스의 분리와 자기참조 빈
#### 7.2.1. XML 파일 매핑
- bean태그안에 SQL 정보를 넣어두는 것이 아닌, SQL을 저장하는 전용 포맷을 가진 독립적인 XML파일을 이용
- JAXB
    - 가장 간단하게 XML에 담긴 정보를 파일에서 읽어올 수 있는 방법
    - XML문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑해준다
    - XML의 정보를 담고있는 오브젝트 트리구조로 만들어준다
    - <sql> 태그를 가진 XML문서를 사용하자
    - 언마샬링 : XML문서를 읽어서 자바의 오브젝트로 변환
    - 마샬링 : 바인딩 오브젝트를 XML문서로 변환
    - getSql() : SQL을 맵에서 찾아서 돌려줌

#### 7.2.2. XML파일을 이용하는 SQL 서비스
- 일단 생성자에서 SQL을 읽어와 내부에 저장하는 초기작업을 한다
- 생성자에서 JAXB를 이용해 XML로 된 SQL문서를 읽어들이고, 변환된 SQL오브젝트들을 맵으로 옮겨서 저장해뒀다가 DAO의 요청에 따라 SQL을 찾아서 전달하는 SqlService

#### 7.2.3. 빈의 초기화 작업
- 일단 초기 상태를 가진 오브젝트를 만들어놓고 별도의 초기화 메소드를 사용
- 바뀔가능성이 있는 XML파일의 이름은 외부에서 DI로 설정
- 오브젝트를 만드는 시점에서 sqlProvider.loadSql()과같이 초기화 메소드를 호출
- @PostConstruct :  빈 오브젝트의 초기화 메소드를 지정
    - 초기화 작업을 수행할 loadSql()메소드에 부여해주면, 스프링은 DI를 마친 후 @PostConstruct가 붙은 메소드를 자동으로 실행
    - **생성자와는 달리, 프로퍼티까지 모두 준비된 후에 실행**
    - @PostConstruct를 단 메소드의 코드는 모든 프로퍼티의 값이 준비됐다고 가정하고 작성

#### 7.2.4. 변화를 위한 준비 : 인터페이스 분리
- SQL을 가져오는 것과 보관해두고 사용하는 것을 유연하게 확장가능하도록 DI를 적용해보자
##### 책임에 따른 인터페이스 정의
- XmlSqlService구현에서 독립적으로 변경가능한 책임
    - 1. SQL 정보를 외부의 리소스로부터 읽어오는 것
    - 2. 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해주는 것
    - 3. 서비스를 위해 한 번 가져온 SQL을 필요에 따라 수정할 수 있게 하는 것

![image](https://user-images.githubusercontent.com/32324250/61366535-b5489500-a8c4-11e9-9695-3ff397d39982.png)
- SqlReader는 내부에 갖고 있는 SQL 정보를 형식을 갖춰서 돌려주는 대신， 협력관계에 있는 의존 오브젝트인 SqlRegistry에게 필요에 따라 등록을 요청할 때만 활용하면 된다. 
![image](https://user-images.githubusercontent.com/32324250/61366703-11abb480-a8c5-11e9-9c38-4021fc0d304f.png)

#### 7.2.5. 자기참조 빈으로 시작하기
##### 다중 인터페이스 구현과 간접 참조
![image](https://user-images.githubusercontent.com/32324250/61367577-e1fdac00-a8c6-11e9-9817-0464271493a1.png)
- 책임에 따라 분리되지 않았던 XmlSqlService 클래스를 일단 세분화된 책임을 정의한 인터페이스를 구현
- 같은 클래스의 코드이지만 책임이 다른 코드는 직접 접근하지 않고 인터페이스를 통해 간접적 으로 사용하는 모드로 변경
- SqlReader나 sqlRegistry를 구현한 코드에서 xmlSqlService내의 다른 변수와 메소드를 직접 참조하거나 사용하면 안된다
- 필요한 경우에만 적절한 인터페이스를 통해 접근한다

#### 7.2.6. 디폴트 의존관계
- 확장 가능한 인터페이스를 정의하고 인터페이스에 따라 메소드를 구분해서 DI가 가능하도록 모드를 재구성
- 이를 완전히 분리해두고 DI로 조합해서 사용
- 디폴트 의존관계 : 외부에서 DI 받지 않는 경우 기본적으로 자동 적용되는 의존관계
    - DI 설정이 없을 경우 디폴트로 적용하고 싶은 의존 오브젝트를 생성자에서 넣어준다.
    -  특별히 DI가 필요한 상황이 아닌 대부분의 경우에는 편리하게 사용할 수 있다.
    - 실패 : DefaultSqlService 내부에서 생성하는 JaxbXmlSqlReader의 sqlmapFile 프로퍼티가 비어 있기 때문이다
    - 해결 : sqlmapFile의 경우도 JaxbXmlSqlReader에 의해 기 본적으로 사용될 만한 디폴트 값을 넣어준다

    ```java
    private static final String DEFAULT_SQLMAP_FILE = .sqlmap.xm
    ```


### 7.3. 서비스 추상화 적용
#### 7.3.1. OXM 서비스 추상화
- JAXB외에도 Castor MXL, JiBX, XmlBeans, Xstream과 같은 XML/자바 오브젝트 바인딩 기술도 있다.
- OXM(Obejct-XML-Mapping) : XML과 자바오브젝트를 매핑하여 상호 변환해줌
- OXML에 대한 서비스 추상화가 필요 : 스프링이 제공하는 OXM 추상계층의 API를 이용해 XML문서와 오브젝트 사이의 변환을 처리

#### 7.3.2 OXM 서비스 추상화 적용