# 토비의 스프링 3.1 Vol.1
## 6장 : AOP 

### 6.1. 트랜잭션 코드의 분리
- 트랜잭션에서 비즈니스 로직을 담당하는 코드를 메소드로 추출
=> 트랜잭션을 담당하는 기술적인 코드가 UserService내에 있는 문제
=> 트랜잭션 코드를 클래스 밖으로 뽑아내자

- DI 적용을 이용한 트랜잭션 분리
    - DI : 실제 사용할 오브젝트의 클래스 정체는 감춘 채, 인터페이스를 통해 간접적으로 접근
    => UserService를 인터페이스로 만들고, 이를 구현하는 UserServiceImpl을 만든다
    => UserService를 구현하는 UserServiceTx 를 만들어 트랜잭션의 경계설정을 담당시킨다.
    => TransactionManager 라는 이름의 빈으로 등록된 트랜잭션 매니저를 DI로 받아뒀다가, 트랜잭션 안에서 동작하도록 만들어줘야하는 메소드 호출의 전과 후에 필요한 트랜잭션 경계설정 API를 사용해주면 된다.

### 6.2. 고립된 단위 테스트
- 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것
- 그 원인을 찾기가 쉽다!

#### 6.2.1. 복잡한 의존관계 속의 테스트
- 여러개를 의존하는 경우, 배보다 배꼽이 더 큰경우 발생
#### 6.2.2. 테스트 대상 오브젝트 고립시키기
- 테스트를 위한 대역을 사용하자!
- UserServiceImpl 을 고립시키자
- UserServiceImpl을 테스를 위해 만들어진 MockUserDao, MockMailSender에만 의존하게 만든다



- 테스트 스텁 : 테스트 대상의 코드가 정상적으로 수행되도록 도와줌
- 목 오브젝트 : 뿐만 아니라, 부가적인 검증기능까지 가능

#### 6.2.3. 단위테스트와 통합테스트
- 단위테스트 : 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 것
- 통합테스트 : 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트 하거나, 외부의 DB파일, 서비스 등의 리소스가 참여하는 테스트

- 가이드 라인
    - 단위테스트를 먼저 고려
    - 외부와의 의존관계를 차단하고, 목 오브젝트나 스텁의 테스트 대역을 이용
    - 외부 리소스가 반드시 필요한 테스트는 통합테스트로

#### 6.2.4. 목 프레임워크
- 대부분 의존 오브젝트를 필요로 하는 코드를 테스트하기 때문에 목 오브젝트가 필수적
- Mockito 프레임워크 : 목 오브젝트를 편리하게 작성하도록 도와주는 목 오브젝트 지원 프레임워크
    - 목 클래스를 일일히 준비해둘 필요 없이, 간단한 호출로 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.
    
    ``` java
    UserDao mockUserDao = mock(UserDao.class);
    when(mockUserDao.getAll()).thenRetrun(this.users);
    UserServiceImpl.setUserDao(mockUserDao); //테스트 대상에 DI
    verify(mockUserDao, times(2)).update(any(User.class)); //any는 파라미터의 내용은 무시하고, 호출 횟수만 확인.
    
    ```
    - mock()은 org.mockito.Matchers에 정의된 스태틱 메소드
    - Mockito의 static 메소드를 한 번 호출해주면 목 오브젝트가 만들어진다.
    - Mockito 오브젝트는 인터페이스를 이용해 목 오브젝트를 만든다.
    - getAll()이 호출될 때, users의 목록을 반환
    - User타입의 오브젝트를 파라미터로 받으면, update()메소드가 2번 호출됐는지 확인하라


### 6.3. 다이내믹 프록시와 팩토리 빈
#### 6.3.1. 프록시와 프록시 패턴, 데코레이터 패턴
- 프록시 : 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것
- 타킷, 실체 : 프록시를 통해 최종적으로 요청을 받아 처리하는 실제 오브젝트
- 프록시 패턴 : 타깃에 대한 접근방법을 제어하려는 목적을 가진 경우. 타깃의 기능을 확장하거나 추가하지 않고 클라이언트가 타깃에 접근하는 방식을 변경해준다.
- ex) 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 할 때, 타깃 보으젝트를 만드는 대신 프록시를 넘겨준다. 그리고 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다. 레퍼런스는 갖고있지만 끝까지 사용하지 않는 경우면 프록시를 통해 생성을 최대한 늦춤으로써 얻는 장점이 많음.
- 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고있는 경우가 많음

- 데코레이터 패턴 : 타깃에 부가적인 기능을 런타임 시 다이내믹하게(컴파일 시점에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않음) 부여해주기 위해 프로시를 사용하는 패턴. 인터페이스로 선언하여, 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만든다.
- ex) InputStream, OutputStream, 스프링의 빈 주입

#### 6.3.2. 다이내믹 프록시
- 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트
- 프록시는 기존 코드에 영향을 주지 않으면서, 타깃의 기능을 확장하거나 접근방법을 제어할 수 있는 유용한 방법
- java.lang.reflect 에 프록시를 쉽게 만들 수 있도록 지원해주는 클래스가 있음
- 리플렉션 : 자바의 코드 자체를 추상화해서 접근하도록 만든 것. 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다. 
- 팩토리 빈 : 스프링을 대신하여 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈

#### 6.3.5. 프록시 팩토리 빈 방식의 장점과 한계
장점 - 프록시 팩토리 빈의 재사용. 기존 코드에 부가적인 기능을 추가해줄 수 있다.
    - 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거

단점 - 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하는 일이 불가능
    - 하나의 타깃에 여러개의 부가기능을 적용하려고 할 때에도, 프록시 팩토리 빈 설정이 부가기능의 개수만큼 붙어야하므로 코드의 양이 늘어난다.
    - TransactionHandler가 프록시 팩토리 빈 개수만큼 만들어진다.


### 6.4. 스프링의 프록시 팩토리 빈
#### 6.4.1. ProxyFactoryBean
- 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈
- 프록시를 생성하는 작업만을 담당, 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있다.
- 어드바이스 : 타깃이 필요없는 순수한 부가기능 - MethodInvocation은 타깃 오브젝트의 메소드를 실행할 수 있는 기능이 있기 때문에 부가기능을 제공하는 데에만 집중할 수 있다. 부가기능을 제공하는 오브젝트
- 포인트 컷 : 부가기능 적용 대상 메소드 선정 방법. 프록시에 부가기능 적용 메소드를 선택하는 기능을 넣는 것. 메소드 선정 알고리즘을 담은 오브젝트
- 포인트컷과 어드바이스를 Advisor타입의 오브젝트에 담아서 조합을 만들어 등록
- 어드바이저 : 어드바이스와 포인트컷을 묶은 오브젝트

#### 6.4.2. ProxyFactoryBean 적용
- MethodInterceptor라는 Advice 서브인터페이스를 구현해서 만든다.
- 어드바이스와 포인트컷의 재사용. ProxyFactoryBean은 스프링의 DI, 템플릿콜백, 서비스 추상화가 모두 적용된 것. 독립적이며 여러 프록시가 공유할 수 있는 어드바이스와 포인트컷으로 확장 기능을 분리할 수 있다.