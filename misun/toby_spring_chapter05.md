# 토비의 스프링 3.1 Vol.1

## 5장 : 서비스 추상화
- 트랜잭션을 사용하여 스프링이 어떻게 추상화는 하는지 살펴보자

### Level 이늄
- DB에 같은 종류의 String값을 넣는 것보단 범위가 작은 숫자가 넣는게 용량면에서 우수
- 그러나, int형의 경우 우연히 값이 맞을 가능성, 범위가 벗어나는 값을 넣을 위험성 존재
=> 숫자타입을 직접사용하기보단 이늄(enum)을 사용하자 
(ex)level타입의 오브젝트이기 때문에, 안전하게 사용할 수 있다
- intValue() : DB저장용 값을 얻기위해 사용
- valueOf() : Level타입의 이늄 오브젝트로 만듦

### 트랜잭션 서비스 추상화
- 작업 수행도중 네트워크가 끊기거나 서버에 장애가 생겨 작업을 완료할 수 없다면, 모두 초기상태로 돌리는 것이 나음
- 이를 테스트하기 위해 UserService를 상속하여 테스트에 필요한 기능을 추가하도록 일부 메소드를 오버라이딩하는게 나음
- 트랜잭션 : 더 이상 나눌 수 없는 단위 작업 (원자성)
- 트랜잭션 롤백 : 두 가지 작업 중 두번째 SQL이 성공적으로 DB에서 수행되기 전에 문제가 발생할 경우, 앞에서 처리한 SQL작업도 취소시키는 것
- 트랜잭션 커밋 : 여러개의 SQL 수행이 다 성공적으로 마무리됐다고 DB에게 알려줘서 작업을 확정시키는 것
- 트랜잭션 경계 : 트랜잭션이 시작되고 끝나는 위치
- JDBC에서 트랜잭션의 경계 설정 (Connection 내에서)
    - 1. 자동커밋옵션을 False로 만들기(디폴트가 true)
    - 2. commit() 또는 rollback()으로 트랜잭션을 종료
    - 하나의 트랜잭션으로 묶이러면 그 작업이 진행되는 동안, DB커넥션도 하나만 사용돼야 한다.
- 로컬 트랜잭션 : 하나의 DB 커넥션 안에서 만들어지는 트랜잭션
- 글로벌 트랜잭션 : 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리 (여러개의 DB)

### 트랜잭션 동기화 
- 비즈니스 로직 내에서 트랜잭션을 처리하고 싶을 때, Connection은 만들어줘야함
- 그대신, 그 때 생성한 Connection 오브젝트를 DAO호출할 때 사용하는건 피해야 함 (UserDao는 더이상 데이터 액세스 기술에 독립적일 수 없다, 깔끔하게 DB커넥션을 처리할 수 있는 JdbcTemplate을 사용할 수 없음, 서비스로직에 Connection파라미터라니 ㅜㅜ)
- 이를 해결하기위해, 독립적인 저장소에 서비스 트랜잭션을 시작하기 위해 만든 Connection객체를 보관해두고, 이후에 호출된 DAO의 메소드에서는 저장된 Connection을 가져다가 사용하게 함
- 트랜잭션이 끝나면 이 Connection 오브젝트를 삭제함
- 이때, 트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리함
=> 로직을 담은 메소드에 Connection 타입의 파라미터가 전달될 필요가 없다.
- TransactionSynchronizationManager : 스프링이 제공하는 트랜잭션 동기화 관리 클래스
- 이 클래스의 유틸리티 메소드를 사용하면, Connection오브젝트를 생성해주고 트랜잭션 동기화에 사용되도록 저장소에 바인딩해준다.
- JdbcTemplate은 스스로 Connection을 생성하여 사용한다.
- 자바는 JTA(Java Transaction API)를 통해 글로벌 트랜잭션을 지원

### 트랜잭션 서비스 추상화
- 특정 기술(Connection, UserTransaction, Session/Transaction API )에 의존적인 트랜잭션을 피하기위하여, 트랜잭션의 경계설정을 담당하는 일정한 패턴의 코드를 추상화 시켜 트랜잭션 관리 계층을 만든다. 그리고 애플리케이션 코드에서는 트랜잭션 추상계층이 제공하는 API를 이용하여 트랜잭션을 이용한다.
- PlatformTransactionManager : 스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스 (JDBC의 경우는 이를 구현한 DataSourceTransactionManager)
- getTranscation() : 트랜잭션을 가져오는 요청

### 서비스 추상화와 단일 책임 원칙
- 단일 책임 원칙 : 하나의 모듈은 한 가지 책임을 가져야 하며, 하나의 모듈이 바뀌는 이유는 한 가지여야 한다.
- 단일 책임 원칙의 장점 : 어떤 변경이 필요할 때 수정 대상이 명확해진다. 기술이 바뀌면 기술 계층과의 연동을 담당하는 기술 추상화 계층의 설정만 바꿔주면 된다.
=> 이를 하기위한 핵심적인 도구가 스프링의 DI (PlatformTransactionManaver의 생성과 의존관계 설정을 스프링에 맡긴 덕에, 트랜잭션 기술에서 자유로운 UserService를 가질 수 있음)

### 메일 서비스 추상화
- SMTP 프로토콜을 지원하는 메일 전송 서버가 필요
    - 테스트시에는, 테스트 DB를 사용하듯이 테스트용으로 따로 준비된 메일 서버를 이용하자
    - 이 때에는, 전송 요청은 받지만 실제 메일이 발송되지 않도록 설정

- JavaMail : 자바에서 메일을 발송하는 표준 기술 
    - javax.mail 패키지 : 확장이나 지원이 불가능하도록 만들어진 가장 악명높은 표준 API
    - javaMail API를 통해 요청이 들어간다는 보장만 있으면 테스트시에 JavaMail을 직접 구동시킬 필요가 없다.
    - Session 오브젝트를 만들어야 메일 메시지를 생성하고, 전송할 수 있다.
    - Session은 final 클래스이며, 생성자 모두 private 
    => 추상화로 문제를 해결! MainSender 구현 클래스를 만들어서 DI해주자

- 메일 발송 기능에도 트랜잭션을 구현
    - MainSender를 구현한 트랜잭션 기능이 있는 메일 전송용 클래스를 만든다
    - 이 오브젝트에 업그레이드 작업 이전에 새로운 메일 전송 작업을 알려주고, 그 때부터는 mailSender.send()메소드를 호출해도 실제로 메일을 발송하지 않고 저장해둔다.
    - 업그레이드 작업이 끝나면 지금까지 저장된 메일을 모두 발송하고, 예외가 발생하면 모두 취소한다.

#### 테스트 환경에서 유용한 기법 : 테스트할 대상이 의존하고 있는 오브젝트를 DI를 통해 바꿔치기 하자.
- 의존한다 : 종속되거나, 기능을 사용한다.
- DummyMailServer를 의존하게 하였다. (UserService가 반드시 이용해야하는 의존 오브젝트의 역할을 해주며, 테스트중에 UserService의 코드가 실행되게 해준다.)
- 테스트 대역 : 테스트 화경을 만들어주기 위해, 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게, 자주  테스트를 실행할 수 있도록 사용하는 오브젝트
- 테스트 스텁 : 대표적인 태스트 대역. 태스트 스럽은 태스트 대상 오브젝 트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는 것
- 목 오브젝트 : 테스트 대상의 간접적인 출력 결과를 검증하고, 테스트 대상 오브젝트와 의존 오브젝트 사이에 일어나는 일을 검증할 수 있도록 설계된 것. 테스트 대상과 의존 오브젝트 사이에 주고받는 정보를 보존해두는 기능을 가진 태스 트용 의존 오브젝트