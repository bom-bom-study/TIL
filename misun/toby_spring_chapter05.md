# 토비의 스프링 3.1 Vol.1

## 5장 : 서비스 추상화
- 트랜잭션을 사용하여 스프링이 어떻게 추상화는 하는지 살펴보자

### Level 이늄
- DB에 같은 종류의 String값을 넣는 것보단 범위가 작은 숫자가 넣는게 용량면에서 우수
- 그러나, int형의 경우 우연히 값이 맞을 가능성, 범위가 벗어나는 값을 넣을 위험성 존재
=> 숫자타입을 직접사용하기보단 이늄(enum)을 사용하자 
(ex)level타입의 오브젝트이기 때문에, 안전하게 사용할 수 있다
- intValue() : DB저장용 값을 얻기위해 사용
- valueOf() : Level타입의 이늄 오브젝트로 만듦

### 트랜잭션 서비스 추상화
- 작업 수행도중 네트워크가 끊기거나 서버에 장애가 생겨 작업을 완료할 수 없다면, 모두 초기상태로 돌리는 것이 나음
- 이를 테스트하기 위해 UserService를 상속하여 테스트에 필요한 기능을 추가하도록 일부 메소드를 오버라이딩하는게 나음
- 트랜잭션 : 더 이상 나눌 수 없는 단위 작업 (원자성)
- 트랜잭션 롤백 : 두 가지 작업 중 두번째 SQL이 성공적으로 DB에서 수행되기 전에 문제가 발생할 경우, 앞에서 처리한 SQL작업도 취소시키는 것
- 트랜잭션 커밋 : 여러개의 SQL 수행이 다 성공적으로 마무리됐다고 DB에게 알려줘서 작업을 확정시키는 것
- 트랜잭션 경계 : 트랜잭션이 시작되고 끝나는 위치
- JDBC에서 트랜잭션의 경계 설정 (Connection 내에서)
    - 1. 자동커밋옵션을 False로 만들기(디폴트가 true)
    - 2. commit() 또는 rollback()으로 트랜잭션을 종료
    - 하나의 트랜잭션으로 묶이러면 그 작업이 진행되는 동안, DB커넥션도 하나만 사용돼야 한다.
- 로컬 트랜잭션 : 하나의 DB 커넥션 안에서 만들어지는 트랜잭션
- 글로벌 트랜잭션 : 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리 (여러개의 DB)

### 트랜잭션 동기화 
- 비즈니스 로직 내에서 트랜잭션을 처리하고 싶을 때, Connection은 만들어줘야함
- 그대신, 그 때 생성한 Connection 오브젝트를 DAO호출할 때 사용하는건 피해야 함 (UserDao는 더이상 데이터 액세스 기술에 독립적일 수 없다, 깔끔하게 DB커넥션을 처리할 수 있는 JdbcTemplate을 사용할 수 없음, 서비스로직에 Connection파라미터라니 ㅜㅜ)
- 이를 해결하기위해, 독립적인 저장소에 서비스 트랜잭션을 시작하기 위해 만든 Connection객체를 보관해두고, 이후에 호출된 DAO의 메소드에서는 저장된 Connection을 가져다가 사용하게 함
- 트랜잭션이 끝나면 이 Connection 오브젝트를 삭제함
- 이때, 트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리함
=> 로직을 담은 메소드에 Connection 타입의 파라미터가 전달될 필요가 없다.
- TransactionSynchronizationManager : 스프링이 제공하는 트랜잭션 동기화 관리 클래스
- 이 클래스의 유틸리티 메소드를 사용하면, Connection오브젝트를 생성해주고 트랜잭션 동기화에 사용되도록 저장소에 바인딩해준다.
- JdbcTemplate은 스스로 Connection을 생성하여 사용한다.
- 자바는 JTA(Java Transaction API)를 통해 글로벌 트랜잭션을 지원

### 트랜잭션 서비스 추상화
- 특정 기술(Connection, UserTransaction, Session/Transaction API )에 의존적인 트랜잭션을 피하기위하여, 트랜잭션의 경계설정을 담당하는 일정한 패턴의 코드를 추상화 시켜 트랜잭션 관리 계층을 만든다. 그리고 애플리케이션 코드에서는 트랜잭션 추상계층이 제공하는 API를 이용하여 트랜잭션을 이용한다.
- PlatformTransactionManager : 스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스 (JDBC의 경우는 이를 구현한 DataSourceTransactionManager)
- getTranscation() : 트랜잭션을 가져오는 요청