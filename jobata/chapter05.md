# 5장 서비스 추상화

## 5.1 사용자 레벨 관리 기능 추가
- 지금까지의 UserDao
  - User 오브젝트에 담겨 있는 사용자 정보를 CRUD하는 기초적인 작업만 가능
    - 사용자 정보를 DB에 넣고 빼는 것을 제외하면 어떤 비즈니스 로직도 갖고 있지 않음.
- 비즈니스 로직을 추가해보자.
  - UserDao를 다수의 회원이 가입할 수 있는 인터넷 서비스의 사용자 관리 모듈에 적용한다고 생각해보자.
    - 사용자 관리 기능
      - 정보를 넣고 검색
      - 정기적으로 사용자의 활동내역을 참고해서 레벨을 조정해주는 기능
    - 비즈니스 로직
      - 사용자의 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나다.
      - 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.
      - 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER 레벨이 된다.
      - SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
      - 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.

#### 5.1.1 필드 추가
- Level 이늄
  - User에 추가할 프로퍼티 타입을 int로 한다면?
    - 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다.
  - 숫자 타입을 직접 사용하는 것 보다는 enum을 사용하자.
    - `사용자 레벨용 이늄`
      ```java
      public enum Level {
        BASIC(1), SILVER(2), GOLD(3);  // 세 개의 이늄 오브젝트 정의

        private final int value;

        Level(int value) {  // DB에 저장할 값을 넣어줄 생성자를 만들어둔다.
          this.value = value;
        }

        public int intValue() {  // 값을 가져오는 메소드
          return value;
        }

        public static Level valueOf(int value) {  // 값으로부터 Level 타입 오브젝트를 가져오도록 만든 스태틱 메소드
          switch(value) {
            case 1: return BASIC;
            case 2: return SILVER;
            case 3: return GOLD;
            default: throw new AssertionError("Unknown value: " + value);
          }
        }
      }
      ```
    - Level enum은 내부에는 DB에 저장할 int 타입의 값을 갖고 있지만, 겉으로는 Level 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다.
      - user1.setLevel(1000)과 같은 코드도 컴파일러가 타입이 일치하지 않는다는 에러를 내면서 걸러줄 것이다.
- 기존 코드에 새로운 기능을 추가하려면 테스트를 먼저 만드는 것이 안전하다.
  - 테스트에서 유용하게 쓰려면 각각 다른 값을 넣는 것이 좋다.
- Level enum은 오브젝트이므로 DB에 저장될 수 있는 SQL 타입이 아니다.
  - 가능한 정수형 값으로 변환해줘야 한다.
  - 반대로 조회시는 int 타입의 값을 Level 타입의 이늄 오브젝트로 만들어 준다.
- JDBC가 사용하는 SQL은 컴파일 과정에서 검증이 되지 않는 단순 문자열에 불과하다.
  - SQL 문장이 안성돼서 DB에 전달되기 전까지는 문법 오류나 오타를 발견하기 힘들다.
  - 빠르게 실행 가능한 포괄적인 테스트를 만들어두는 것이 좋다.

#### 5.1.2 사용자 수정 기능 추가
- 가장 많은 실수가 일어나는 SQL 문장
  - UPDATE 문장에서 WHERE절을 빼먹은 경우
    - JdbcTemplate의 update()가 돌려주는 리턴 값을 확인한다.
    - 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인한다.

#### 5.1.3 UserService.upgradeLevels()
- 사용자 관리 비즈니스 로직을 담을 UserService 클래스
  - UserDao 인터페이스 타입으로 userDao 빈을 DI 받아 사용하게 만든다.
    - UserService는 UserDao의 구현 클래스가 바뀌어도 영향받지 않도록 해야 한다.
- if, else if, else로 사용자 레벨 조건 검사 및 변경

#### 5.1.4 UserService.add()
- 처음 가입하는 사용자의 레벨을 BASIC으로 초기화하는 로직은 어디에?
  - UserDaoJdbc?
    - User 오브젝트를 DB에 정보를 넣고 읽는 방법에만 관심을 가져야한다. 바람직하지 않다.
  - User 클래스에서 초기화?
    - 처음 가입할 때를 제외하면 무의미한 정보인데 클래스에서 직접 초기화하는 것은 좀 문제가 있다.
  - UserService?
    - UserService에도 add()를 만들어두고 사용자가 등록될 때 적용할 만한 비즈니스 로직을 담당하게 하면 될 것이다.

#### 5.1.5 코드 개선
- 작성된 코드를 살펴볼 때 다음과 같은 질문을 해볼 필요가 있다.
  - 코드에 중복된 부분은 없는가?
  - 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
  - 코드가 자신이 있어야 할 자리에 있는가?
  - 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?
- upgradeLevels() 메소드 코드의 문제점
  - 레벨의 변화 단계와 업그레이드 조건, 조건이 충족됐을 때 해야할 작업이 섞여 있다.
- upgradeLevels() 리팩토링
  - 업그레이드가 가능한지 확인한다.
    - 가능하면 true, 불가하면 false return
  - 업그레이드 조건을 만족했을 경우 구체적으로 무엇을 할 것인가?
    - 사용자의 레벨을 다음 단계로 바꿔주는 것과 변경사항을 DB에 업데이트해주는 것
      - 다음 단계 레벨이 무엇인지 결정하는 일은 Level에 맡긴다.
        - Level 타입의 next 변수를 추가하고 생성자 파라미터를 추가한다.
  - 사용자 정보가 바뀌는 부분을 UserService 메소드에서 User로 옮긴다.
    - User의 내부 정보가 변경되는 것은 User가 스스로 다루는게 적절하다.
- 객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다.
- 항상 코드를 더 깔끔하고 유연하면서 변화에 대응하기 쉽고 테스트하기 좋게 만들려고 노력하자.
- 테스트 코드는 테스트의 의도를 알 수 있도록 만들자.
- 숫자의 중복은 상수로 해결하자.

## 5.2 트랜잭션 서비스 추상화

#### 5.2.1 모 아니면 도
- 모든 사용자에 대해 업그레이드 작업을 진행하다가 중간에 예외가 발생해서 작업이 중단된다면?
  - 이미 변경된 사용자의 레벨은 자업 이전 상태로 돌아갈까?
  - 아니면 바뀐 채로 남아 있을까?
  - 테스트를 만들어서 확인해보자.
    - 예외적인 상황을 작업 중간에 강제로 발생시켜야 한다.
    - 테스트의 기본은 자동화된 테스트여야한다.
      - DB 서버를 다운시키거나 네트워크를 끊는 등의 강제적인 장애 상황을 연출하는 사람이 간섭하는 것은 좋은 생각이 아니다.
      - 예외가 던져지는 상황을 의도적으로 만드는 게 낫다.
- UserService를 상속한 테스트용 클래스를 만든다.
- 트랜잭션 문제로 테스트 결과는 실패
  - 모든 사용자의 레벨을 업그레이드하는 작업이 하나의 트랜잭션 안에서 동작하지 않았기 때문이다.

#### 5.2.2 트랜잭션 경계설정
- DB는 그 자체로 완벽한 트랜잭션을 지원한다.
  - 하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을 보장해준다고 믿을 수 있다.
  - 하지만 여러 개의 SQL이 사용되는 작업은?
    - 반드시 하나의 트랜잭션으로 묶여서 일어나야 한다.
      - 트랜잭션 롤백, 트랜잭션 커밋
- JDBC 트랜잭션의 트랜잭션 경계설정
  - 모든 트랜잭션은 시작하는 지점과 끝나는 지점이 있다.
    - 시작하는 방법은 한 가지이지만 끝나는 방법은 롤백과 커밋 두 가지
  - 트랜잭션의 경계
    - 트랜잭션이 시작되고 끝나는 위치
  - 자동커밋 옵션을 flase로 만들어주면 트랜잭션을 시작한다.
    - setAutoCommit(false)
    - JDBC의 기본 설정은 DB 작업을 수행한 직후에 자동으로 커밋이 되도록 되어 있기 때문이다.
  - 트랜잭션이 시작되면 커밋과 롤백 메소드가 호출될 때까지 작접이 하나의 트랜잭션으로 묶인다.
    - commit(), rollback()
  - 로컬 트랜잭션(local transaction)
    - 하나의 DB 커넥션 안에서 만들어지는 트랜잭션
- 어떤 일련의 작업이 하나의 트랜잭션으로 묶이려면 그 작업이 진행되는 동안 DB 커넥션도 하나만 사용돼야 한다.
  - DAO에에서 DB 커넥션을 매번 만들기 떄문에 UserService 내에서 진행되는 여러 가지 작업을 하나의 트랜잭션으로 묶는 일이 불가능해진다.
  - 어떻게 해결할까?

#### 5.2.3 트랜잭션 동기화
- 트랜잭션 동기화
  - 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고, 이후에 호출되는 DAO의 메소드에서는 저장된 Connection을 가져다가 사용하게 하는 것
  - DAO가 사용하는 JdbcTemplate이 트랜잭션 동기화 방식을 이용하도록 하는 것
  - 작업 흐름
    - ![image](https://user-images.githubusercontent.com/36880294/57007099-f49a0a80-6c20-11e9-8e7f-c909a8d510e3.png)
  - 트랜잭션 동기화 저장소
    - 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리하기 때문에 멀티스레드 환경에서도 충돌이 날 염려는 없다.
- 적용
  - 스프링이 제공하는 트랜잭션 동기화 관리 클래스 TransactionSynchronizationManager
    - initSynchronization()으로 초기화하도록 요청
  - 스프링이 제공하는 유틸리티 메소드 DataSourceUtils 클래스의 getConnection()
    - Connection 오브젝트를 생성해줄 뿐만 아니라 트랜잭션 동기화에 사용하도록 저장소에 바인딩해준다.
- JdbcTemplate은 영리하게 동작하도록 설계되어 있다.
  - 만약 미리 생성돼서 트랜잭션 동기화 저장소에 등록된 DB 커넥션이나 트랜잭션이 없는 경우 직접 DB 커넥션을 만들고 트랜잭션을 시작해서 JDBC 작업을 진행한다.
  - 반면에 트랜잭션 동기화를 시작해놓았다면 그때부터 실행되는 JdbcTemplate의 메소드에서는 트랜잭션 동기화 저장소에 들어 있는 DB 커넥션을 가져와서 사용한다.

#### 5.2.4 트랜잭션 서비스 추상화
- 여러 개 DB로의 작업을 하나의 트랜잭션으로 만드는 건 로컬 트랜잭션으로는 불가능하다.
  - 로컬 트랜잭션은 하나의 DB Connection에 종속되기 때문이다.
- 글로벌 트랜잭션
  - 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 방식
- 글로벌 트랜잭션을 적용해야 트랜잭션 매니저를 통해 여러 개의 DB가 참여하는 작업을 하나의 트랜잭션으로 만들 수 있다.
- JTA
  - 자바에서 JDBC 외에 글로벌 트랜잭션을 지원하는 트랜잭션 매니저를 지원하기 위한 API
  - ![image](https://user-images.githubusercontent.com/36880294/57007610-ec43ce80-6c24-11e9-81cb-cb8cebc14411.png)
- 트랜잭션 API의 의존관계 문제와 해결책
  - ![image](https://user-images.githubusercontent.com/36880294/57007668-6d02ca80-6c25-11e9-8420-5c8e5e5cb8df.png)
  - 특정 트랜잭션 방법에 의존적이지 않고 독립적일 수 있게 만들려면 어떻게 해야 할까?
    - SQL을 이용하는 방식이라는 공통점을 뽑아내 추상화한 JDBC처럼 트랜잭션 처리 코드에도 추상화를 도입한다.
- 스프링의 트랜잭션 서비스 추상화
  - ![image](https://user-images.githubusercontent.com/36880294/57007729-d5ea4280-6c25-11e9-8a56-725ffff987db.png)
- 어떤 트랜잭션 매니저 구현 클래스를 사용할지 UserService 코드가 알고 있는 것은 DI 원칙에 위배된다. 
  - 자신이 사용할 구체적인 클래스를 스스로 결정하고 생성하지 말고 컨테이너를 통해 외부에서 제공받게 히는 스프링 DI의 방식으로 바꾸자.
    - 설정파일의 transactionManager 빈의 설정만 바꿔주면 됨.

## 5.3 서비스 추상화와 단일 책임 원칙
- 수직, 수평 계층구조와 의존관계
  - 기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.
  - ![image](https://user-images.githubusercontent.com/36880294/57007982-afc5a200-6c27-11e9-86d2-0c063dce1f76.png)
  - 애플리케이션 로직의 종류에 따른 수평적인 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는 데는 스프링의 DI가 중요한 역할을 하고 있다.
    - DI의 가치는 이렇게 관심, 책임, 성격이 다른 코드를 깔끔하게 분리히는 데 있다.
- 단일 책임 원칙(SRP)
  - 하나의 모듈은 한가지 책임을 가져야 한다. 하나의 모듈이 바뀌는 이유는 한가지여야 한다.
  - 트랜잭션 서비스의 추상화 방식을 도입, 이를 DI를 통해 외부에서 제어하도록 만든다.
- DI를 잘 활용하자!
  - 객체지향 원칙과 디자인 패턴의 장점이 잘 녹아 있는 코드가 된다.
  - 스프링을 사용함으로써 얻을 수 있는 가장 큰 장점

## 5.4 메일 서비스 추상화
- 목 오브젝트를 이용한 테스트
  - 보통의 테스트 방법으로는 검증하기 까다로운 테스트 대상 오브젝트의 내부에서 일어나는 일이나 다른 오브젝트 사이에서 주고 받는 정보까지 검증하는 일이 쉬워진다.

## 5.5 정리
- 비즈니스 로직을 담은 UserService 클래스를 만들고 트랜잭션을 적용하면서 스프링의 서비스 추상화에 대해 살펴보았다.
- 주요 내용
  - 비즈니스 로직을 담은 코드는 데이터 액세스 로직을 담은 코드와 깔끔하게 분리되는 것이 바람직하다. 비즈니스 로직 코드 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메소드로 정리돼야 한다.
  - 이를 위해서는 DAO의 기술 변화에 서비스 계층의 코드가 영향을 받지 않도록 인터페이스 와 DI를 잘 활용해서 결합도를 낮춰줘야 한다.
  - DAO를 사용히는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 펼요하다.
  - 트랜잭션의 시작과 종료를 지정하는 일을 트랜잭션 경계설정이라고 한다. 트랜잭션 경계설
정은 주로 비즈니스 로직 안에서 일어나는 경우가 많다.
  - 시작된 트랜잭션 정보를 담은 오브젝트를 따라미터로 DAO에 전달하는 방법은 매우 비효
율적이기 때문에 스프링이 제공하는 트랜잭션 동기화 기법을 활용하는 것이 편리하다.
  - 자바에서 사용되는 트랜잭션 API의 종류와 방법은 다양하다 환경과 서버에 따라서 트랜잭션 방법이 변경되면 경계설정 코드도 함께 변경돼야 한다.
  - 트랜잭션 방법에 따라 비즈니스 로직을 담은 코드가 함께 변경되면 단일 책임 원칙에 위배되며， DAO가 사용하는 특정 기술에 대해 강한 결합을 만들어낸다.
  - 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 된다.
  - 서비스 추상회는 로우레벨의 트랜잭션 기술과 API의 변회에 상관없이 일관된 API를 가진 추상화 계층을 도입한다.
  - 테스트 대상이 사용하는 의존 오브젝트를 대체할 수 있도록 만든 오브젝트를 테스트 대역이라고 한다.
  - 테스트 대역은 테스트 대상 오브젝트가 원활하게 동작할 수 있도록 도우면서 테스트를 위해 간접적인 정보를 제공해주기도 한다.
  - 테스트 대역 중에서 테스트 대상으로부터 전달받은 정보를 검증할 수 있도록 설계된 것을 목 오브젝트라고한다.
