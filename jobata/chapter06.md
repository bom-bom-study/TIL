# 6장 AOP

## 6.1 트랜잭션 코드의 분리
- PSA를 적용한 UserService
  - but, 트랜잭션 경계설정을 위해 넣은 코드가 많은 자리를 차지하고 있어 깔끔하지 못하다.

#### 6.1.1 메소드 분리
- upgradeLevels()
  - 메소드 구성
    - 트랜잭션 시작
    - 비즈니스 로직
    - 트랜잭션 종료
  - 메소드 특징
    - 트랜잭션 경계설정 코드와 비즈니스 로직 간에 서로 주고 받는 정보가 없다.
      - 비즈니스 로직에서 직접 DB를 사용하지 않기 때문에 트랜잭션 준비 과정에서 만드러진 DB 커넥션 정보 등을 직접 참조할 필요가 없기 때문
    - 트랜잭션 정보는 트랜잭션 동기화 방법을 통해 DAO가 알아서 활용한다.
  - 그렇다면?
    - 트랜잭션 경계설정과 비즈니스 로직은 서로 독립적인 코드이므로 두 개의 메소드로 분리할 수 있지 않을까?
- 우선 비즈니스 로직 부분만 따로 메소드로 분리하여 보았음.
  - 하지만 아직 트랜잭션을 담당하는 기술적인 코드가 버젓이 UserServcie 안에 자리 잡고 있다.

#### 6.1.2 DI를 이용한 클래스의 분리
- UserService를 인터페이스로 만들고 기존 코드의 비즈니스 로직과 트랜잭션 경계설정을 UserService 인터페이스의 구현 클래스를 만들어 넣도록 한다.
  - 클라이언트와의 결합은 낮아지고
  - 직접 구현 클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능
  - ![image](https://user-images.githubusercontent.com/36880294/58157973-71665480-7cb4-11e9-80f2-d86d099ebccb.png)
- UserService 인터페이스
  ```java
  public interface UserService {
    void add(User user);
    void upgradeLevels();
  }
  ```
- UserServiceImpl 클래스
  ```java
  public class UserServiceImpl implements UserService {
    UserDao userDao;
    MailSender mailSender;

    public void upgradeLevels() {
      List<User> users = userDao.getAll();
      for (User user : users {
        if (canUpgradeLevel(user)) {
          upgradeLevel(user);
        }
      })
    }
    /*
      ...
    */
  }
  ```
- UserServiceTx 클래스
  ```java
  public class UserServiceTx implements UserService {
    UserService userService;
    PlatfromTransactionManager transactionManager;

    public void setUserService(UserService userService) {
      this.userService = userService;
    }

    public void SetTransactionManager(PlatformTransactionManager transaction Manager) {
      this.transactionManager = transactionManager;
    }

    public void add(User user) {
      userService.add(user);
    }

    public void upgradeLevels() {
      TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
      try {
        userService.upgradeLevels();
        this.transactionManager.commit(status);
      } catch (RuntimeException e) {
        this.transactionManager.rollback(status);
        throw e;
      }
    }
  }
  ```
- 클라이언트가 UserService 인터페이스를 통해 사용자 관리 로직을 이용하려고 할 때 먼저 트랜잭션을 담당하는 오브젝트가 사용돼서 트랜잭션에 관련된 작업을 진행해주고, 실제 사용자 관리 로직을 담은 오브젝트가 이후에 호출돼서 비즈니스 로직에 관련된 작업을 수행하도록 만든다.
  - ![image](https://user-images.githubusercontent.com/36880294/58159114-cefba080-7cb6-11e9-983c-406aaa32b376.png)
- 트랜잭션 경계설정 코드 분리의 장점
  - 비즈니스 로직을 담당하고 있는 UserServicelmpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다.
  - 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다는 것

## 6.2 고립된 단위 테스트
- 작은 단위 테스트의 장점
  - 테스트가 실패했을 때 원인을 찾기 쉽다.
  - 테스트의 의도나 내용이 분명해진다.
  - 만들기 쉽다.

#### 6.2.1 복잡한 의존관계 속의 테스트
- UserService 테스트 동작
  - ![image](https://user-images.githubusercontent.com/36880294/58159631-e8511c80-7cb7-11e9-8cc0-a361f304cc93.png)
  - 배보다 배꼽이 더 큰 작업이다.
    - UserServcie를 테스트하는 것처럼 보이지만 의존관계 때문에 사실은 그 뒤에 존재하는 더 많은 오브젝트와 환경, 서비스, 서버, 심지어 네트워크까지 함께 테스트하는 셈이 된다.

#### 6.2.2 테스트 대상 오브젝트 고립시키기
- 테스트의 대상을 고립시켜야 한다.
  - 테스트 스텁이나 목 오브젝트를 사용하여 테스트의 대상이 환경이나 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록해야한다.
- 테스트를 위한 UserServiceImpl 고립
  - ![image](https://user-images.githubusercontent.com/36880294/58160315-2e5ab000-7cb9-11e9-927a-b50657929827.png)
  - 사전에 테스트를 위해 준비된 동작만 하도록 만든 두 개의 목 오브젝트에만 의존하는 완벽하게 고립된 테스트 대상으로 만들 수 있다.
  - but, 의존 오브젝트나 외부 서비스에 의존하지 않는 고립된 테스트 방식으로 만든 UserServicelmpl은 아무리 그 기능이 수행돼도 그 결과가 DB 등을 통해서 남지 않으니, 기존의 방법으로는 작업 결과를 검증하기 힘들다.
    - UserDao에게 어떤 요청을 했는지 확인하는 작업이 필요
    - UserDao와 같은 역할을 하면서 UserServicelmpl과의 사이에서 주고받은 정보를 저장해뒀다가, 태스트의 검증 에 사용할 수 있게 하는 목 오브젝트를 만들 필요가 있다.
- 고립된 단위 테스트 활용
  - 기존 upgaradeLevels() 테스트 
    - DB 테스트 데이터 준비
    - 메일 발송 여부 확인을 위해 목 오브젝트 DI
    - 테스트 대상 실행
    - DB에 저장된 결과 확인
    - 목 오브젝트를 이용한 결과 확인
  - MockUserDao를 사용해서 만든 고립된 테스트
    - 테스트 대상 오브젝트를 직접 생성한다.
    - 목 오브젝트로 만든 UserDao를 직접 DI 해준다.
    - MockUserDao로부터 업데이트 결과를 가져온다.
    - 업데이트 횟수와 정보를 확인한다.
- 테스트 수행 성능의 향상
  - 고립된 테스트를 하면 태스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 펼요가 없을 뿐만 아니라, 테스트 수행 성능도 크게 향상된다.

#### 6.2.3 단위 테스트와 통합 테스트
- 단위 테스트
  - 태스트 대상 클래스를 목 오브젝트 등의 태스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 태스트하는 것
- 통합 테스트
  - 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 태스트
- 단위 테스트와 통합 테스트 중 어떤 방법을 쓸 것인가?
  - 항상 단위 테스트를 먼저 고려한다.
  - 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 태스트를 만든다.
  - 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
  - DAO는 DB까지 연동하는 태스트로 만드는 편이 효과적이다.
  - DAO를 태스트를 통해 충분히 검증해두면 DAO를 이용하는 코드는 DAO 역할을 스텁이나 목 오브젝트로 대체해서 테스트할 수 있다.
  - 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다.
  - 단위 테스트를 만들기가 너무 복잡하다고 판단되는 표드는 처음부터 통합 테스트를 고려해 본다.
    - 이때도 통합 테스트에 참여하는 코드 중에서 가능한 한 많은 부분을 미리 단위 테스트로 검증해두는게 유리하다.
  - 스프링 태스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트다.
- 테스트에 대한 생각
  - 단위 테스트와 통합 테스트 모두 개발자가 스스로 자신이 만든 묘드를 테스트하기 위해 만드는 개발자 테스트다.
  - 코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관이다.
  - 테스트하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될 가능성이 높다.
  - 스프링이 지지하고 권장히는 깔끔하고 유연한 코드를 만들다보면 테스트도 그만큼 만들기 쉬워지고， 테스트는 다시 코드의 품질을 높여주고, 리팩토링과 개선에 대한 용기를 주기도 할 것이다.

#### 6.2.4 목 프레임워크
- 번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.
- Mockito 프레임워크
  - 인터페이스를 이용해 목 오브젝트를 만든다.
  - 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다.
    - 메소드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
  - 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
  - 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.

## 6.3 다이내믹 프록시와 팩토리 빈

#### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴
- 전략 패턴 적용
  - ![image](https://user-images.githubusercontent.com/36880294/58164458-da53c980-7cc0-11e9-895d-5ab5d1ce3abf.png)
  - 전략 패턴으로는 트랜잭션 기능의 구현 내용을 분리해냈을 뿐이다.
  - 트랜잭션을 적용한다는 사실은 그대로 코드에 남아 있다.
  - 구체적인 구현 코드는 제거했을지라도 위임을 통해 기능을 사용하는 핵심 코드와 함께 남아 있다.
- 부가기능과 핵심 기능의 분리
  - ![image](https://user-images.githubusercontent.com/36880294/58164604-1e46ce80-7cc1-11e9-8b30-4f36ee9f7e77.png)
  - UserService 인터페이스를 통해 UserServiceTx와 UserServiceImpl 구현체 클래스를 만들었다.
  - 부가기능 전부를 핵심 코드가 담긴 클래스에서 독립시킬 수 있다.
  - 부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 한다.
    - 핵심기능은 부가기능을 가진 클래스의 존재 자체를 모른다.
    - 따라서 부가기능이 핵심기능을 사용하는 구조가 된다.
  - 문제는 클라이언트가 핵심기능을 가진 클래스를 직접 사용한다면?
    - 부가기능이 적용될 기회가 없다.
    - 그래서 부가기능은 마치 자신이 핵심 기능을 가진 클래스인 것처럼 꾸며서 자신을 거쳐서 핵심 기능을 사용하도록 만들어야 한다.
- 핵심기능 인터페이스의 적용
  - ![image](https://user-images.githubusercontent.com/36880294/58164961-c6f52e00-7cc1-11e9-8fce-99b92af6bbf6.png)
  - 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고, 부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야 한다.
  - 클라이언트는 인터페이스만 보고 사용을 하기 때문에 자신은 핵심기능을 가진 클래스를 사용할 것이라고 기대하지만 사실은 부가기능을 통해 핵심기능을 이용하게 되는 것이다.
  - 부가기능 코드에서는 핵심기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인 기능을 적용해 줄 수 있다.
    - 비즈니스 로직 코드에 트랜잭션 기능을 부여해주는 경우가 예시
- 프록시(Proxy)
  - 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 프록시라고 부른다.
- 타깃(target) or 실체(real subject)
  - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트
- 프록시와 타깃을 사용하는 구조
  - ![image](https://user-images.githubusercontent.com/36880294/58165220-4e42a180-7cc2-11e9-83ce-4e3bab292b61.png)
- 프록시의 특징
  - 타깃과 같은 인터페이스를 구현했다는 것
  - 프록시가 타깃을 제어할 수 있는 위체이 있다는 것
- 프록시 사용 목적
  - 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서
  - 타깃에 부가적인 기능을 부여해주기 위해서
- 데코레이터 패턴
  - 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
    - 다이내믹하게 기능을 부가한다는 의미?
      - 컴파일 시점 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻
  - 데코레이터라고 불리는 이유?
    - 제품이나 케익 등을 여러 겹으로 포장하고 그 위에 장식을 부팅는 것처럼 실제 내용물은 동일하지만 부가적인 효과를 부여해줄 수 있기 때문이다.
  - 프록시가 한개로 제한되지 않는다.
    - 프록시가 직접 타깃을 사용하도록 고정시킬 필요가 없다.
    - 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있다.
      - 여러 개인 만큼 순서를 정해서 단계적으로 위임하는 구조로 만들면 된다.
  - 소스코드를 출력하는 기능을 가진 핵심기능에 적용한 예
    - ![image](https://user-images.githubusercontent.com/36880294/58165598-0c662b00-7cc3-11e9-866c-12a0780f80c4.png)
  - 데코레이터 패턴은 인터페이스를 통해 위임하는 방식이다.
    - 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.
    - 데코레이터 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어야 한다.
  - 데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.
- 프록시 패턴
  - 용어의 구분
    - 일반적으로 사용하는 프록시
      - 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법
    - 프록시 패턴
      - 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우
  - 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다.
  - 프록시 패턴 적용 예
    - 타깃 오브젝트에 대한 레퍼런스가 미리 필요할 수 있을 때
      - 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트는 만드는 대신 프록시를 넘겨주는 것이다.
      - 그리고 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.
      - 만약 레퍼런스는 갖고 있지만 끝까지 사용하지 않거나, 많은 작업이 진행된 후에 사용되는 경우라면 이렇게 프록시를 통해 생성을 최대한 늦춤으로써 얻는 장점이 많다.
    - 원격 오브젝트를 이용하는 경우
      - RMI나 EJB, 또는 각종 리모팅 기술을 이용해 다른 서벼에 존재하는 오브젝트를 사용해야 한다면, 원격 오브젝트에 대한 프록시를 만들어두고, 클라이언트는 마치 로컬에 존재하는 오브젝트를 쓰는 것처럼 프록시를 시용하게 할 수 있다.
      - 프록시는 클라이언트의 요청을 받으면 네트워크를 통해 원격의 오브젝트를 실행하고 결과를 받아서 클라이언트에게 돌려준다.
      - 클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공해주는 프록시 패턴의 예라고 볼 수 있다.
    - 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위해
      - 수정 가능한 오브젝트가 있는데, 특정 레이어로 넘어가서는 읽기전용으로만 동작하게 강제해야 한다고 하자.
      - 이럴때는 오브젝트의 프록시를 만들어서 사용할 수 있다. 프록시의 특정 메소드를 사용하려고 하면 접근이 불가능하다고 예외를 발생시키면 된다.
  - 클라이언트가 타깃에 접근하는 방식을 변경해준다.
  - 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이다.
  - 프록시 패턴과 데코레이터 패턴의 혼용
    - ![image](https://user-images.githubusercontent.com/36880294/58167746-a203b980-7cc7-11e9-9676-3e229328163e.png)
    - 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.
      - 생성을 지연하는 프록시라면 구체적인 생성 방법을 알아야 하기 때문에 타깃 클래스에 대한 직접적인 정보를 알아야 한다.
      - 물론 인터페이스를 통해 위임하도록 만들 수도 있다.
    - 접근제어를위한프록시를두는프록시 패턴과 컬러, 페이징 기능을 추가하기 위한 프록시를 두는 데코레이터 패턴을함께 적용한 예다.
    - 두가지 모두 프록시의 기본 원리대로 타깃과 같은 인터페이스를 구현해두고 위임하는 방식으로 만들어져 있다.
- 앞으로는 타깃과 통일한 인터페이스를 구현하고 클라이언트와 타깃 사이에 존재하면서 기능의 부가 또는 접근 제어를 담당히는 오브젝트를 모두 프록시라고 부르겠다.
  - 그때마다 사용의 목적이 기능의 부가인지, 접근 제어인지를 구분해보면 각각 어떤 목적으로 프록시가 사용됐는지 그에 따라 어떤 패턴이 적용됐는지 알 수 있을 것이다.

#### 6.3.2 다이내믹 프록시
- 프록시도 일일이 모든 인터페이스를 구현해서 클래스를 새로 정의하지 않고도 편리하게 만들어서 사용할 방법은 없을까?
  - java.lang.reflect 패키지 안에 프록시를 손쉽게 만들 수 있도록 지원해주는 클래스들이 있음.
- 프록시의 구성
  - 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다.
  - 지정된 요청에 대해서는 부가기능을 수행한다.
- 프록시를 만들기 번거로운 이유?
  - 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다.
  - 부가기능 코드가 중복될 가능성이 많다.
- 이러한 번거로움은 JDK의 다이내믹 프록시로 해결 가능하다.
- 리플렉션
  - 자바의 코드 자체를 추상화해서 접근하도록 만든 것
  - (java.lang.reflect 패키지)[https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html]
- 프록시 클래스
  - Hello 인터페이스
    ```java
    public interface Hello {
      String sayHello(String name);
      String sayHi(String name);
      String sayThankYou(String name);
    }
    ```
  - 타깃 클래스
    ```java
    public class HelloTarget implements Hello {
      public String sayHello(String name) {
        return "Hello " + name;
      }

      public String SayHi(String name) {
        return "Hi " + name;
      }

      public String SayThankYou(String name) {
        return "Thank You " + name;
      }
    }
    ```
  - 클라이언트 역할의 테스트
    ```java
    @Test
    public void simpleProxy() {
      Hello hello = new HelloTarget();  // 타깃은 인터페이스를 통해 접근하는 습관을 들이자.
      assertThat(hello.sayHello("Toby"), is("Hello Toby"));
      assertThat(hello.sayHi("Toby"), is("Hi Toby"));
      assertThat(hello.sayThankYou("Toby"), is("Thank You Toby"));
    } 
    ```
  - 프록시 클래스
    ```java
      public class HelloUppercase implements Hello {
        Hello hello;  // 다른 프록시를 추가할 수도 있으니 인터페이스로 접근

        public helloUppercase(Hello hello) {
          this.hello = hello;
        }

        public String sayHello(String name) {
          return hello.sayHello(name).toUpperCase();  // 위임과 부가기능 적용
        }

        public String SayHi(String name) {
          return hello.sayHi(name).toUpperCase();
        }

        public String SayThankYou(String name) {
          return hello.sayThankYou(name).toUpperCase();
        }
      }
    ```
  - 프록시 적용의 일반적인 문제점 두 가지를 모두 갖고 있다.
    - 인터페이스의 모든 메소드를 구현해 위임하도록 코드를 만들어야 한다.
    - 부가기능이 모든 메소드에 중복돼서 나타난다.
- 다이내믹 프록시 적용

#### 6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능
- 다이내믹 프록시 동작 방식
  - ![image](https://user-images.githubusercontent.com/36880294/58169265-4dfad400-7ccb-11e9-89ba-fee43bfea0a2.png)

#### 6.3.4 다이내믹 프록시를 위한 팩토리 빈

#### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

## 6.4 스프링의 프록시 팩토리 빈

#### 6.4.1 ProxyFactoryBean

#### 6.4.2 ProxyFactoryBean 적용
