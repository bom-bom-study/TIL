# 4장 예외

## 4.1 사라진 SQLException
- thorws SQLexception 선언이 JdbcTemplate 적용 후 사라졌다.

#### 4.1.1 초난감 예외처리
- 예외 블랙홀
  - 예외를 잡고는 아무것도 하지 않는다.
    - 아무것도 하지 않고 넘어가 버리는 건 정말 위험하다.
      - 어디선가 발생한 예외로 기능이 비정상적으로 동작하거나, 메모리나 리스소가 소진되거나, 예상치 못한 다른 문제를 일으킬 것이다.
  - 굳이 예외를 잡아서 뭔가 조치를 취할 방법이 없다면 잡지 말아야 한다.
    - 메소드에 throw SQLException을 선언해서 밖으로 던지고 자신을 호출한 코드에 예외처리 책임을 전가해버려라.
- 무의미하고 무책임한 throws
  - 모든 예외를 무조건 던져버리는 선언을 기계적으로 넣는 것도 좋지 않다.
  - 메소드 선언에서 의미 있는 정보를 얻을 수 없게된다.
  - 정말 무엇인가 실행 중에 예외적인 상황이 발생할 수 있다는 것인지, 아니면 습관적으로 복붙한건지 알 수 없다.

#### 4.1.2 예외의 종류와 특징
- Error
  - 에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다.
  - JVM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안된다.
- Exception과 체크 예외
  - 개발자들이 만든 애클리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.
  - 체크 예외
    - Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상속하지 않은 것들
  - 반드시 예외를 처리하는 코드를 함께 작성해야 한다. catch 문으로 잡든지 throws를 정의해서 메소드 밖으로 던져야 한다. 그렇지 않으면 컴파일 에러가 발생한다.
- RuntimeException과 언체크/런타임 예외
  - 언체크/런타임 예외
    - RuntimeException을 상속한 클래스
    - 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다.
    - 또는 대표 클래스 이름을 따서 런타임 예외라고도 한다.
  - 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다.
  - 이런 예외는 코드에서 미리 조건을 체크하도록 주의 깊게 만든다면 피할 수 있다.
  - 런타임 예외는 예상하지 못했던 상황에서 발생하는 게 아니기 때문에 굳이 catch나 throws를 사용하지 않아도 된다.

#### 4.1.3 예외처리 방법
- 예외 복구
  - 예외상황을 파악하고 문제를 해결해서 장상 상태로 돌려놓는 것
- 예외처리 회피
  - 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것
- 예외 전환
  - 예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드 밖으로 던지는 것
    - 예외 회피와 달리 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다는 특징이 있다.
  - 목적
    - 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서
    - 예외를 처리하기 쉽고 단순하게 만들기 위해 포장(wrap)하는 것

#### 4.1.4 예외처리 전략
- 런타임 예외의 보편화
  - 항상 복구할 수 있는 예외가 아니라면 일단 언체크 예외로 만드는 경향이 있다.
  - 언체크 예외라도 필요하다면 얼마든지 catch 블록으로 잡아서 복구하거나 처리할 수 있다.
  - 하지만 대개는 복구 불가능한 상황이고 보나마나 RuntimeException 등으로 포장해서 던져야 할테니 아예 API 차원에서 런타임 예외를 던지도록 만드는 것이다.
- 애플리케이션 예외
  - 시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고 반드시 catch해서 무엇인가 조치를 취하도록 요구히는 예외

#### 4.1.5 SQLException은 어떻게 됐나?
- SQLException은 복구가 가능한 예외인가?
  - 불가능하다.
- 필요도 없는 기계적인 thorws 선언이 등장하도록 방치하지 말고 가능한 빨리 언체크/런타임 예외로 전환해줘야 한다.
- 스프링의 API 메소드에 정의되어 있는 대부분의 예외는 런타임 예외다.
  - 따라서 발생 가능한 예외가 있다고 하더라도 이를 처리하도록 강제하지 않는다.

## 4.2 예외 전환
- 예외 전환 목적
  - 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws를 줄여주는 것
  - 로우레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바꿔서 던져주는 것

#### 4.2.1 JDBC의 한계
- 비표준 SQL
  - DAO를 DB별로 만들어 사용하거나 SQL을 외부에서 독립시켜서 바꿔 쓸 수 있게 해야한다.
- 호환성 없는 SQLException의 DB 에러정보
  - 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 코드를 가진 SQLException만으로 DB에 독립적인 유연한 코드를 작성하는 건 불가능에 가깝다.

#### 4.2.2 DB 에러 코드 매핑을 통한 전환
- 스프링의 에러 코드 매핑을 통한 DataAccessException 방식을 사용하는 것이 이상적이다.

#### 4.2.3 DAO 인터페이스와 DataAccessException 계층구조
- DAO 인터페이스와 구현의 분리
- 데이터 액세스 예외 추상화와 DataAccessException 계층구조

#### 4.2.4 기술에 독립적인 UserDao 만들기
- 인터페이스 적용
- 테스트 보완
- DataAccessException 활용 시 주의사항

## 4.3 정리
- 엔터프라이즈 애플리케이션에서 사용할 수 있는 바람직한 예외처리 방법이 무엇인지 알아봤다.
- JDBC 예외의 단점이 무엇인지 살펴보고, 스프링이 제공하는 효과적인 데이터 액세스 기술의 예외처리 전략과 기능에 대해서도 알아봤다.
- 주요 내용
  - 예외를 집아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발히는 것은 위험하다.
  - 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야 한다.
  - 좀 더 의미 있는 예외로 변경하거나 불필요한 catch/throws를 피하기 위해 런타임 예외로 포장하는 두 가지 방법의 예외 전환이 있다.
  - 복구할 수 없는 예외는 가능한 한 빨리 런타임 예외로 전환하는 것이 바람직하다.
  - 애플리케이션의 로직을 담기 위한 예외는 체크 예외로 만든다.
  - JDBC의 SQLException은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해야 한다.
  - SQLException의 에러 코드는 DB에 종속되기 때문에 DB에 독립적인 예외로 전환될 필요가 있다.
  - 스프링은 DataAccessException을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다.
  - DAO를 데이터 액세스 기술에서 독립시키려변 인터페이스 도입과 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요하다.
